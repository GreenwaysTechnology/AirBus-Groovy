Software Setup:

JDK 11 :

>java --version
java 11 2022-03-22
Java(TM) SE Runtime Environment (build 18+36-2087)
Java HotSpot(TM) 64-Bit Server VM (build 18+36-2087, mixed mode, sharing)

Intellij idea,vscode,Ecplise

Groovy sdk
.............................................................................................
				  Groovy
.............................................................................................
What is Groovy? Groovy Programming language?

Groovy is programming language for jvm.


JVM -Java Virtual Machine - To run java applications

JVM helps to build platform indepdendent applications.

java application can be written using programming language called "Java programming language"

Java pl
 -It is high level pl
 -Object oriented Programming.

Java applications:

Editions:

-JAVA SE - Standard Edition - Core java
-JAVA EE - Enterprise edition - Server apps - web apps,Web services,databases,distributed...
-JAVA ME - Micro Edition - Mobile,card,device apps.

Java Technology created by SUN microsystem at 1989,later acquired by Oracle.
.............................................................................................
				  Java Technology Standards
............................................................................................

Standards:
1.ANSI -  C,SQL  
2.ECMA - Javascript

Who defines the Java standards?
JCP - Java Community Process

Java Technologies standardized by JCP Via JSR(Java Specification Request).

JSR-No - JSR-253 - Java 11

Core spec:
1.jvm spec

2.jse spec

3.jee spec
   servlet spec
   webservice spec
...........................................................................................
		         JSR 223: Scripting for the JavaTM Platform


JSR-223 Spec was released on Jun-09-2003.

Before this specification, only one programming language was there for JVM, Java Programming language.

This spec  aim is to introduc new Programming languages for JVM.

Based on this Spec, the first alternate language was created for JVM -  Groovy Programming language.

Groovy was the first  Scripting language for jvm ,which was created based JSR-223 Spec.

///////////////////////////////////////////////////////////////////////////////////////////

		  Groovy is dialect of java which is running on JVM.



Java Program Flow:

  				    JAVA code  - Hello.java
					 | 
                                    java compiler-javac -Hello.class (byte code)
                                          |
                                      java Hello - Run time
					|
				    Java Runtime Env -JVM



Poly Glot : many programming language can be executed on single Runtime.

JVM Poly glot.
       
                JPL  Groovy   Kotlin   JRuby Scala Clojure .... 
		-----------------------------------------------
				|
			     .class
				|
			       JVM

Groovy is programming language inspired from java,Ruby,Javascript,Perl, Smalltalk, Objective-C
..............................................................................................
				   Programming language styles
.............................................................................................

All Programming language follows the styles / Paradigm (way of writting code)

Common Paradigms:

1.Functional Programming Style
2.Procedural Based
3.Object oriented
3.Rule based
etc.....

What is C?
  C is Procedural based programming language.

What is C++?
  C++ is Object oriented Programming language

What is Java?
  Java was Object Oriented Programming language
  Java is Object Oriented Programming,functional style language

What is Javascript?
  Javascript is Object based, functional style Programming language - Hybrid Style Language.

What is Groovy?
  Groovy is Object Oriented,functional Style Programming language - Hybrid Style Lanaugage

............................................................................................
				   Typing
............................................................................................				  
Typing defines the data type of "data", data is stored inside place holder called "variable".

Based on Data Type languages can be classified.

1.static typed or strongly typed
  during variable declaration we must declare type of variable,if not lanaguage compiler gives error
  int a=10;
   a=10
 eg : c,c++,java...

2.dynamic typed or weak typed
 during variable declaration we need not  declare type of variable. 
  var a =10;
  let b=10;

eg: java script,python.....

Groovy is both static and dynamic typed language.

int a=10; //strong/static typing
def b=90;; //dynamic typed

Groovy is Object Oriented,functional Style,static,dynamic typed Programming language
..............................................................................................
				 Style Of Program
.............................................................................................

if you take any program, which follows some language syntax, which is more difficult to understand. Layman cant understand code.

eg: c program,java program - 

C:

    /*
     * C program to accept N numbers and arrange them in an ascending order
     */
 
    #include <stdio.h>
    void main()
    {
 
        int i, j, a, n, number[30];
        printf("Enter the value of N \n");
        scanf("%d", &n);
 
        printf("Enter the numbers \n");
        for (i = 0; i < n; ++i)
            scanf("%d", &number[i]);
 
        for (i = 0; i < n; ++i) 
        {
 
            for (j = i + 1; j < n; ++j)
            {
 
                if (number[i] > number[j]) 
                {
 
                    a =  number[i];
                    number[i] = number[j];
                    number[j] = a;
 
                }
 
            }
 
        }
 
        printf("The numbers arranged in ascending order are given below \n");
        for (i = 0; i < n; ++i)
            printf("%d\n", number[i]);
 
    }

if you look at this code you cant understand easily because you are not professional coder.

but what if systems enginer need to code? 
 
it is not possible like above. what if every body want to understand code? How code should be?

 Code should be like english statements.

sort 1..10 numbers in desc order - This is code /program
       ***************************************************************************


if code is written based on pure language syntax, those language is called "GPL" -  General Purpose Programming language. -  C,C++,Java,Groovy

if code is written based on  layman/ english like language , those language is called "DSL" -  DOMAIN Specific Programming language. - Groovy
    "sort 1..10 numbers in desc order" -  DSL code

                        "Groovy can help to write DSL Code"

if you are able to write code more readable(dsl), that code is called "Declarative code /Declarative programming".

if you are writing code which is less readable that code is called "Imperative code".

DSL code:
 move left,move right, 
 take 1 cup of milk add 2 gm sugar
 shutdown machine-1 at 1 pm every day and restart after 2pm 

Machine Health Checkup:
1.find Machine at all locations
2.filter machines which are unhealthy
3.prepare report in pdf mail to healthCheckMaster@tcs.com
4.do this every day at 1pm

Groovy dsls are easy to understand by stack holders,tools users,end users,dev ops enginers.

Types of DSL Persons:

1.DSL Authors
   Who creates DSL's - eg Jenkins JOB dsl
2.DSL Users
   who uses DSL written by others

............................................................................................
			Groovy can help us to write more declarative code
............................................................................................
Groovy is
  -object oriented
  -functional style
  -dynamic typed
  -static typed 
  -delcarative
  -dsl
Programming language.


Core Features of Groovy Lanaguage:

1.Closures
2.builders
3.runtime & compile-time meta-programming
4.functional programming
5.type inference and static compilation
6.Integration with existing java stack.

Groovy Eco System:
.................
Groovy is core programming language only.

Web:
  Dynamic Web Apps | RestFull Web Services
1.Grails 
  Framework written using groovy.

Build System:
  1.ANT
  2.Maven
  3.Gradle
  4.Grape

2.Gradle
   Build system for java written in groovy

Testing Framework:
 Junit
3.Spock:
  Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification language.

Tools:
  Jenkins Pipeline projects

Package Managers:

NPM - javascript
Nuget -MS .NET

4.SDKMAN!  -Groovy

5.Microservices:
 Spring with Groovy
 Micronaut  -Groovy

SOAP UI - SCRIPTS Written in groovy.
.............................................................................................
				Tools provided by Groovy

1.compiler 
  groovyc
 compile groovy into .class.
2.groovy
   To run groovy code. here we dont need to compile.
  java Main  groovy Main
3.groovy console
   -Built in ide to write groovy code
4.REPL  - Read Evaulate Print Loop : Interactive cmd line tool.-groovysh : groovy shell - Wrapper to low level services.


         Groovy programs are saved with "filename.groovy"
..............................................................................................
				Groovy Programming Style
..............................................................................................

1.class based
..............

java code

package com.mycom;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }

}

if you look at this code, is java, which always starts with class and main method, without this syntax, we cant run code . - This is called class based.

2.script based

helloworld.groovy

println "Hello Groovy World"

The above code

- dont have its own class like java
- dont have main method like java
- dont have semicollons like java

Any how you are going to run on JVM, but how jvm can run this code without main method and main class.
   Groovy compiler adds class and main method behind the scene.


After compilation Groovy compiler writes a code like below

import org.codehaus.groovy.runtime.InvokerHelper;

class HelloWorld extends Script {    
                 
    def run() {                                 
  	println "hello";               
    }
    static void main(String[] args) {           
        InvokerHelper.runScript(HelloWorld, args)     
    }
}

1.The HelloWorld class extends the groovy.lang.Script class

2.groovy.lang.Script requires a run method returning a value
  the script body goes into the run method

3.the main method is automatically generated
 
4.and delegates the execution of the script on the run   method

/////////////////////////////////////////////////////////////////////////////////////////////

Groovy topics:
.............

Groovy Language:
...............

1.Language Fundamentals
2.Groovy Object orientations
3.Groovy Closures and Functional Programming
4.Groovy Meta Programming
5.Groovy DSL
6.Groovy and Builders
7.Groovy and Collections
8.Groovy and IO
    -File,
    -JSON
    -XML

/////////////////////////////////////////////////////////////////////////////////////////////
1.Language Fundamentals

1.1.Type system
1.2.literals
1.3.variables
1.4.operators
1.5.control structures
1.6.iterators/loops

..........................................................................................
				  variable declaration,Type System,literals
...........................................................................................

Groovy is dynamic , static typed programming lanugage.

variables are other wise called as "identifiers"

syntax:

Strong typing
 
type variable=value

eg;
 int a =10;


//declaring variables - strong Typing / static typed programming
int a=10
println("a = " +  a)  //System.out.println("")
//a="hello"
String name="Subramanian"
println("Your Name " + name) // "" + =>String concatenation.

if you run this code, you will get compile time error.

Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'hello' with class 'java.lang.String' to class 'int'
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'hello' with class 'java.lang.String' to class 'int'
	at strongtyping.run(strongtyping.groovy:4)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)

Data Types:

1.numbers

whole numbers - integers

byte
short
int
long

Size
     byte
 *        -128 to 127
 *        1 byte
 *      short
 *       -32,768 to 32767
 *       2 bytes
 *      int
 *       -2Powof31 to 2powerof32
 *       4 bytes
 *       long
 *       - -2power63 to 2powerof64
 *       8 bytes

decimal numbers
float
double
    float - 4bytes
    double -8bytes
2.characters

char -  single char 
String - collection of chars

3.boolean
boolean 



//whole numbers
//byte b = 180;
byte b=10;
short s = 90;
int i = 1000;
long lng = 199999;
println("byte => " + b);
println("Short => " + s)
println("Int => " + i);
println("Long => " + lng)

//Decimal Numbers
float price = 10.5f; // 4 bytes
println("Float => " + price)
double distance = 187.7865; //8 bytes
println("Double => " + distance);


//characters
char c = 'A'; //characters must be specified with single character
println("Character =>" + c);
//String
String name = "Subramanian";
String city = "Coimbatore";
String zipcode = "642001"
print("Your Details " + name + " , " + city + " , " + zipcode)



//booleans store true or false - 1 bit 0 or 1

boolean isValid = true;
boolean isEnabled = false;
boolean isAlive = true;
println("isValid " + isValid)
println("Is Enabled" + isEnabled)
println("Is Alive " + isAlive)
..............................................................................................
			    Category of data type and Variable
.............................................................................................

1.Primitive Types
  byte,int,short,long,float,double,char,boolean
if any variable is declared with these types are called, primitive variables
2.Reference Types
  Object Types, if a variable is declared with Objects.
 if any variable is delclared with object type are called "reference variables"
 String name;
..............................................................................................
				  Dynamic Typed
.............................................................................................

The type of variable can be changed during runtime, groovy is dynamic typed

syntax;

def identifier(variable)=value(literal)

def - keyword
//Dynamic type declaration

def a = 10
println("A value => " + a);
//now change a value to different type
a = true
println("A value => " + a);
a = "Hello"
println("A value => " + a);
a = 89.90
println("A value => " + a);
..........................................................................................
How to know the Type of Identifier?
  
def myvar=100;

instanceof operator used to know the type of variable.

instanceof operator works only with reference types

myvar instanceof int -  compile time error

int a =10;
println(a instanceof int);  // here you are checking whether a belongs to int

Error
Groovyc: Cannot perform instanceof check against primitive type int


int a =10;
String name = ""
println(name instanceof  String);

output:
 true
..............................................................................................

def b =10;
println(b instanceof  int);

 Here we get error, cant perform instanceof check against primitive type int.

In order to understand this, we need to know one more concept.

When we write dynamic typed program in groovy, groovy never assign primitive types to a variable. Groovy assigns reference types.
---------------------------------------------------------------------------------------------
				Wrapper Types 
.............................................................................................

Every Primitive type has eq Reference Types, which introduced in Java.

Primitive  Reference Type
 byte     - Byte 
 short    - Short
 int      - Integer
 long     - Long
 float    - Float
 double   - Double 
 boolean  - Boolean
 char     - Character 

//int a = 10;
//String name = ""
////println(a instanceof int);  // here you are checking whether a belongs to int
//println(name instanceof String);

def b = 10
println("b belongs to Integer  " + (b instanceof Integer))
println("b belongs to Byte  " + (b instanceof Byte))

def c = 890000009999999
println("c belongs to Integer  " + (c instanceof Integer))
println("c belongs to Long  " + (c instanceof Long))


Code challange:
...............
In java, i want to store the below number, findout right data type.

myvariable =2232333333333333333333333333333333333331212121212092347329473433483473984732948734983473984739473498473289472394238437498479487948749387492479479347943794479;


//int a = 10;
//String name = ""
////println(a instanceof int);  // here you are checking whether a belongs to int
//println(name instanceof String);

def b = 10
println("b belongs to Integer  " + (b instanceof Integer))
println("b belongs to Byte  " + (b instanceof Byte))

def c = 890000009999999
println("c belongs to Integer  " + (c instanceof Integer))
println("c belongs to Long  " + (c instanceof Long))

def bigValue=2232333333333333333333333333333333333331212121212092347329473433483473984732948734983473984739473498473289472394238437498479487948749387492479479347943794479;
println("bigValue belongs to BigInteger " + (bigValue instanceof BigInteger))
..............................................................................................					Type Conversion
..............................................................................................

Java:
 
int a =10

here
 int is type
 a is variable
 10 is value(literal)

What is type of "a"?
  int
What is type of "10"?
 
 Do you think that the type of a and type of "10" would be the same?
 No! 

      "The type of variable and type of value is different"

in Integer family : the default type of value is "int"

int a =10;

a's type is int
10's type is also int.

byte b=10;

Here what is type of b?
byte
Here what is type of 10;
int

byte b=10(int)

1 byte  =  4 byte


Type conversion :
 Converting from one type to another type.

 int to byte

Types of conversion:

 - Implicit conversion
     conversion is taken automatically.

    byte b =10;  === byte == int
    here 10(int) is converted into byte.   
    int b =9000; ==>int === int

eg:
        byte a = 10;  //byte <=== int
        short s =100; // short <===int
        int i =10 ;   // int <=== int
        long lng = 1000; //long <== int

 - Explicit conversion
      We need to convert manually.
  While conversion there is possibility of data loss.

  Syntax
 
      targettype = (targetype)sourcetype
      byte b = (byte)900;
  
      int a = 10; //10 type is int---size 4 bytes
        byte b = 19; // 19 type is ? - int only  // byte(2) === int(4)
        //byte b1 =9000; // here 9000 cant be stored inside b1 because b1 capacity is lesser than value
        //what if i want to store 9000 inside b1
        //type conversion
        byte b2 = (byte)10000;
        System.out.println(b2);


Decimal numbers:
................
What is default type of decimals?

float price = 10.5;  // float === double === 4 bytes ===8 bytes- error

Decimal numbers:
................
What is default type of decimals?

float price = 10.5;  // float === double === 4 bytes ===8 bytes- error

what is type of 10.5?
  double.

type conversion for floating points

ways:

1. by adding f suffix
	
        float price = 10.5f;

here 10.5(double) is converted into float.

2.by using () syntax
      float price1 = (float) 10.5;

..............................................................................................
Characters:

the value of char type is int

        char c = 'A'; //int
        char c1 = 99; //int
        System.out.println(c1 + " " + c);
        System.out.println((char) c1 + " " + (int) c);

byte b = 10000000;
float f = 90.89;
println("byte b =>" + b)
println("flat f =>" + f)
............................................................................................
			 Dynamic Typing and Type Conversion
...........................................................................................

def a = 100
  The type of a is "Integer"

What if i want to mention a type as 

=>Byte
=>Short
=>Long

Groovy offers special operator "as" can convert and represent type 

def myvar = 100;
println myvar instanceof Integer /// int
//What if i want to convert into Short, i want to represent in side short/long/byte
def myvar2 = 100 as Short;
println myvar2 instanceof Integer /// int
println myvar2 instanceof Short /// int
.............................................................................................
				Other Type conversion
.............................................................................................

1.Boxing
2.Unboxing
 
Boxing and Un boxing : converting primitive to wrapper and wrapper to primitive
 

Java :

Integer j = 10;
int y = j * 10;
System.out.println(y);

//type conversion
//int is converted to byte.
byte b = 10000;
println b;
byte b1 = (byte) 10000;
println b1;

float f = 10.5;
float f1 = 10.5f;

println f;
println f1;

Groovy boxing and unboxing:


def a =100  // here 100 is primitive(int)  a is Integer  Integer a = 100
int b = a;  // b is int a is Integer  int b = Integer b
println("a " + a + " b" + b )
.............................................................................................
				comments


Comments;

1.single line comment:

//

2.Muliti line comment
/*

*/

3.Groovydoc comment
 /**
 *
 *
 /

4.Shebang line

#! /user/bin/env/ groovy

  This for running script directly from the commandline in unix operating system.

///////////////////////////////////////////////////////////////////////////////////////////
                               Key words from groovy


NOte: 

 Keywords cant be used as value or variable in groovy.

 eg: 
 as, break,case,catch,class, instance of,for, goto def, enum do, const,...........
//////////////////////////////////////////////////////////////////////////////////////////////
				  Coding standards
..............................................................................................

There are different types  of code

1.variables
2.functions
3.classes
4.methods
5.interfaces
	
variables:

1.variable name must be meaningfull to the problem.

def a=10; //
def productId=10
def firstName="Subramanian"

2.variables must be camelcased.

startswithSmall letter
 
def id=1
def name="subramanian"
def firstName="Dhivya Sree"

3.variables can  
- start with letter,
- start with $
- start with _
- not with numbers
eg:
   def $id
   def _name
   def 1Name => invalid
............................................................................................
				Difference with Java
............................................................................................


Groovy makes code as simple as possible.Groovy uses lot of boilerplate code on behalf of us.

Typical java program structure :

package com.mycompany.project.module.submodule;

import java.util.*;
import java.math.BigInteger;


public class MyClass{

 public static void main(String args[]){

 }
 
}

What is package?
  
   It is way to organize the code into file and folders, physically and logically.
 
in java and groovy code is organized as files and folders inside disk.

Inside code , we use the keyword called "package" key word which represents "this current file belongs to "com/airbus" folder


The default Package:

 if you dont save file inside any subfolders like com/airbus, the programs can be saved inside
project root dir "src"
 This is called default package, no package statement is given.

In groovy scripts are written without package statement, which is valid and also recommended
..............................................................................................
				 Types of packages
..............................................................................................

1.custom packages
   packages created by developer while write apps

package com.airbus.jenkins.pipelines

package follows some coding standards defined by SUN microsystem when java was created.

any package has to start with
 com - company
 org - organization
 companyName 
    hudson.

secondconvention
  companyName -  airbus
Thirdconvention
  Name of the Project - jenkins
Fourth Convention
  Module name  - pipelines 


all private projects starts with "com"

all opensource projects starts with "org"

2.built in packages

 The packages provided by language like java,groovy,scala,kotlin

java Language:
  java.
  javax.

Groovy Lanaguage
  groovy.lang
  groovy.util
  groovy.sql
  org.apache.groovy.antlr

3.third party packages
  The package developed by third parties used by us.

Mostly all tools and frameworks, libs are distrbuted as third party packages.

eg:
 Spring Framework
 Jenkins
..............................................................................................					  How to use packages inside code?
..............................................................................................
How to use package features inside our code?

using the keyword called "import" , to link programs inside our programs

syntax:
 import com.airbus.jenkins.pipelines.CustomJob;
 

eg:
package com.airbus.jenkins.pipelines

class CustomJob {
    void start(){
        println ("......Build Starts.....")
    }
}

How to use This class?

Syntax : 1 - Import only one class

import com.airbus.jenkins.pipelines.CustomJob

def job = new CustomJob()
job.start()


Syntax : 2 : import all classes

import com.airbus.jenkins.pipelines.* // import all classes from inside this dir.

def job = new CustomJob()
job.start()
def pipeline = new CustomPipeline()
pipeline.init()

The 2nd syntax not recommended mostly , the reason is which imports all classes in one short so which degreads performance.
.............................................................................................
				 common packages in java and groovy
.............................................................................................

java.lang - The fundamental language features are provided inside this package without this package we cant write even one single java program.

public class TypeDemo {
    public static void main(String[] args) {
        byte a = 10;  //byte <=== int
        short s = 100; // short <===int
        int i = 10;   // int <=== int
        long lng = 1000; //long <== int

        //explicit conversion
        byte b = (byte) 10000;


        //here f is sufffix used to convert double to float
        float f = 10.5f;  // default type of precision is double
        float f1 = (float) 10.89;

        //Reference Type
        Integer myNumber =100;
        //primitive type
        int myNewNumber =myNumber; //int <== Integer -  Boxing

        Integer myNumber2 = myNewNumber; //Integer <=== int Unboxing

    }
}

if you want to compile and run we need java.lang package must have been imported.

here in the above we have not imported any java.lang package ,still works how?

                   "java by default imports java.lang package"

		     In java only one default package 
.............................................................................................
				Groovy Packages
.............................................................................................

groovy supports both java packages as well as groovy own packages.

groovy.lang is similar to java.lang has all the language core features.

without lang package , we cant write any groovy program..

Groovy compiler automatimatically imports lot of default packages.

java:
1.java.io.*;
2.java.lang.*;
3.java.math.BigDecimal
4.java.math.BigInteger
5.java.net.*
6.java.util.*

Groovy language also has its own packages

 Groovy has extend from java, which supports all java packages + who supports extra packages.

groovy.XXX
groovy.lang.*;
groovy.util.*;
..............................................................................................
					Values(literals) In Groovy
.............................................................................................

1.Strings && Characters
2.Numbers
3.Booleans
4.Lists
5.Arrays
6.Map
7.Objects

Strings:
 Text literals are represented in the form of collection of characters called strings.
 Strings are Objects.
 Strings are instance of java.lang.String class as well as groovy.lang.GString
 Characters in groovy is represented in String object.
 Each character is 16-bit unicode character.


String declaration Patterns:
............................

1.single quoted  - ''
2.Double quoted  = "" 
3.Triple  Single Quoted = '''
4.Triple double quoted = """
5.slashy quoted - / /
6.Dollar slashy quoted - $/ /


1.single quote 
2.double qutote
//String declarations

//single quote

def str1 ='Hello,Groovy'
//double quote
def str2 ="Hello,Groovy How are you?"

//Test both variables are from java or gString
println("Single Quote is Instance of java.lang.String => " +  (str1 instanceof  java.lang.String))
println("Double Quote is Instance of java.lang.String => " +  (str2 instanceof  java.lang.String))
..............................................................................................
				   String Concatnation
.............................................................................................

Using + operator:
.................
This operator derived from java lang.

//Java style of String concatenation  
println "............................."
def name = "Subramanian";
def greeting = 'Hello ' + name;
println greeting;
println greeting instanceof java.lang.String;
//
def firstName="Subramanian";
def lastName = "Murugan"
println("Name " + firstName + lastName)

Interpolation:
 -It is replacement of existing string concation
 -way of access variables/expression inside string is so different
 -This feature is not available in java language
 
in order to add interpolation syntax, groovy has added a new class groovy.lang.GString

GString Syntax:

 "${expression}"
 "$expression"

//How to interpolate strings

def name = "Subramanian"
//here message type is groovy.GString not java.lang.String
def message = "Hello ${name}" // string interpolation
println(message)

//
def host = "airbus.com"
def port = 8080
def url = "/api"
def path = "/pipelines"

//def uri = "http://${host}:${port}${url}${path}";
def uri = "http://$host:$port$url$path";

println(uri)
..............................................................................................
				Multi line Strings
.............................................................................................

//Multi line java synatx:
String title = "Airbus";
String doc = "<html>" +
        "<head>" +
        "<title>" + title + "</title>" +
        "<body>" +
        "<h1> Hello</h1>" +
        "</body>" +
        "</body></html>";
System.out.println(doc);
//Groovy Style :  ''' ''' Using single triple quote : you cant interpolate
def mydoc ='''
  <html>
  <head>
    <title>Airbus</title>
  </head>
  <body>
     <h1>Hello</h1>
  </body>
  </html>  
'''
println(mydoc)
//double triple quote

def message="Hello"

def mynewDoc = """
  <html>
  <head>
    <title>$title</title>
  </head>
  <body>
     <h1>$message</h1>
  </body>
  </html>  
"""
println(mynewDoc)
............................................................................................
				Escaping Special Characters
............................................................................................

//here i want to print single
def quote = " Hello ! how are you? \\ i am fine what \" about you ";
println quote;
quote = ' Hello ! how are you? \' i am fine what about you';
println quote;

quote = " Hello ! how are you? \t \t i am fine what \n about you";
println quote;

def priceInEuro = "Price in Euro \u20AC";
println priceInEuro

special characters you can escape:
...................................

\b - backspace
\f - formfeed
\t  -tab
\s -single space
\' - single quote within single quoted.
\" - double quote witthin another double quote
\unicode - unicode escape
..............................................................................................
				Slashy String
..............................................................................................
Strings inside slash / strings /

Slashy strings are like other string declaration(type of declaration)
Which encapsulate all string declaration features

// '' ,"" ,'''''' ,""" """ ,"\special" "interploation" === \slash\


//Slashy Strings
//syntax1 : normal string
def str = /This is slashy string/
println str
//Syntax 2 : it allows special characters as
def myquote =/How are you! \i am fine \;/;
println myquote
//syntax 3 : multi line with slashy strings
def doc = / hello
 how are you?
 welcome
 greetings   
/;
println doc;

// syntax 4 : interpolation with slashy strings
def name='Subramanian'
def greeting= / Hello ${name} /;
println greeting

Applications of Slashy;

-Text Processing:

  String processing can be done in many ways
  -Using string apis and logic
  -Regular Expression : Regx
     It is one of the DSL Programming language, introduced inside UNIX operating in order to      simlify the Text processing using "some special characters"
  After popularity of Regex, many languages started integrating regular expressions features as language apis.

Java introduced regualar expressions via java.util.regex package 


String mydata = " hey \; \$ hello 0 1, how are y subramanian , 7m3 ";

i want  to extract nos
i want to extract special characters
i want to only $

Task: write a code-java to extract nos,spicial characters,$


Regular Expression Implmentation:
  Regular expression is dsl language to process strings / text
  Regular expression works based on symbols called "Patterns"
 

Regular expression in java:

java.util.regex;

Regular expression uses symbols
 +
 *
 ~
 {}
 ?
https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html

Character classes
[abc]	a, b, or c (simple class)
[^abc]	Any character except a, b, or c (negation)
[a-zA-Z]	a through z or A through Z, inclusive (range)
[a-d[m-p]]	a through d, or m through p: [a-dm-p] (union)
[a-z&&[def]]	d, e, or f (intersection)
[a-z&&[^bc]]	a through z, except for b and c: [ad-z] (subtraction)
[a-z&&[^m-p]]	a through z, and not m through p: [a-lq-z](subtraction)


Simple Pattern syntax:
......................

 \d+ -match /find any number in the string - match any number one or more times

Declare pattern in java
  
   String pattern =  "\d+"; -  this is compile time error because, special characters
needed to be escaped.
   
   String pattern ="\\d+" -  now it is vaild , because we have escaped \+ chacter by \

Drawback of this syntax:
  Very complex , when we form complex regular expressions
eg:
 "\\+d\\+d\\*d ^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$"

package com.airbus.strings;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegularExpressionApp
{
    public static void main(String[] args) {
        //Declare pattern
        String pattern = "\\d+";  //what you want
        System.out.println(pattern);
        //find out all numbers from this string
        String inputString ="hey  hello 0 1, how subramanian 1 , 7m3";
        //logic to extract nos from the string
        //Compile the Pattern
        Pattern compiledPattern = Pattern.compile(pattern);
        Matcher digitMatcher =compiledPattern.matcher(inputString);
        System.out.println("Source String "+ inputString);
        while(digitMatcher.find()) {
            System.out.println(digitMatcher.group());
        }

    }
}
..............................................................................................
		   
		Groovy Simplifies the above pattern matching using "Slashy Strings"
.............................................................................................

How to write regular expressions using groovy?

Version : 1 - Pattern declaration using slashy string
import java.util.regex.Matcher
import java.util.regex.Pattern

println "Regular Expression-Groovy Implementation"
//Step 1: declare input string
def inputString = "hey  hello 0 1, how subramanian , 7m3";
//pattern:
// String pattern = "\\d+";  //java syntax of defining pattern
def pattern = /\d+/ //here we can escape special characters without using special characters
Pattern compiledPattern = Pattern.compile(pattern);
Matcher digitMatcher = compiledPattern.matcher(inputString);
println("Source String " + inputString);
while (digitMatcher.find()) {
    println(digitMatcher.group());
}

Version 2: Replace compile Code:
.................................
-Replace Pattern.compile api with ~/d+/
  => "~" is operator - compile operator,later we will discuss this deeply.

println "Regular Expression-Groovy Implementation"
//Step 1: declare input string
def inputString = "hey  hello 0 1, how subramanian , 7m3";
Pattern compiledPattern = ~/\d+/;
Matcher digitMatcher = compiledPattern.matcher(inputString);
println("Source String " + inputString);
while (digitMatcher.find()) {
 println(digitMatcher.group());
}

Version 3 :  slashy +pattern.compile + pattern.matcher
........................................................
 (inputString =~/\d+/)

 "=~" - Compile + Match operator.

println "Regular Expression-Groovy Implementation"
//Step 1: declare input string
def inputString = "hey  hello 0 1, how subramanian , 7m3";
def compiledPattern = ~/\d+/;
def matcher = (inputString =~ /\d+/)
while (matcher.find()) {
    println(matcher.group());
}
......................................................................................

Coding Challange:
.................
Finding all dates in a String and getting
//the date month and year can be as simple as below

[dd-mm-yyy] - output format

def dates = "28-02-1992 a b c  15-06-1982 15-Apr-1982";

Expected output:

28-02-1992, 15-06-1982
..............................................................................................
				dollar SlashyString
..............................................................................................
->Multi line + String interpolation

  $// - multi line without interploation
  $/""" xxx """/ multi line with interploation


println "Dollar Slashy Strings";

def name ="Subramanian"
def dollarSlashy = $/ 
   Hello,$name
   100
   prices
   1
   groovy
   34
/$
println dollarSlashy
def matcher = (dollarSlashy =~ /\d+/)
while (matcher.find()) {
    println(matcher.group());
}
.............................................................................................
				Number Literals
.............................................................................................


Numbers:

Primitives : 
  byte,short,int,long
  float,double
  boolean
  char
Reference types
  Integer - Wrapper classes
  java.math.BigDecimal , java.math.BigInteger

def a =100;
a instanceof Integer

How groovy identifies Integer
  Integer.MAX_VALUE 

How groovy identifies Long
  Integer.MAX_VALUE + 1 - posstive
  Integer.MAX_VALUE - 1 - negative values

Numbers can be represented 
 -binary
    -prefx 0b

println("Numbers")
println "Binary Numbers"
def a=0b10101111
println a;

 -octaal
     -prefix 0
println "Octal "
def b = 077;
println b;

-hexadecimal
   -prefix  0x

println "Hexa decimals"
def c = 0x77;
println c;


 -decimals

println "Decimal literals"

def d =10;
BigDecimal bd =90.89;
println("$d $bd")

Underscore in literals
......................
  when writing long numbers , its harder to read, in order to group long numbers
 "_" notation is used.

eg: credit card numbers,sss,adharno,bigamount..


println "Under scores"

long creditCardNumber = 1234_5678_9012_3456L;
println creditCardNumber
////////////////////////////////////////////////////////////////////////////////////////////

Number suffixes:

 float f =10.5f

 f / F - float
 d / D - double
 l/L   - long
 G/g   - BigInteger
 G/g    -BigDecimal
 i - Integer

long l = 1233l;
int  j = 89i;
...........................................................................................
				  Booleans
...........................................................................................

Java and Booleans:

In java booleans are represented by boolean type with value "true/false".

boolean isValid =true;
boolean isEnabled=false;

boolean isBig = 10 > 20  // true or false

    boolean isValid = true;
        boolean isEnabled = false;
        //If - conditional statement
        if (isValid) {
            System.out.println("Valid");
        } else {
            System.out.println("Invalid");
        }
        if (isEnabled) {
            System.out.println("Enabled");
        } else {
            System.out.println("disabled");
        }
        if (10 > 20) {
            System.out.println("Big");
        } else {
            System.out.println("Not Big");
        }
        //invalid code
        int a=100;
//        if(a){
//
//        }
.............................*********........................................................
			Groovy truthy and falsy values
..............................................................................................
In Groovy everthing is true execept the below values

falsy values:

1.boolean false
2.0
3."" (Empty string)
4.null 
5.Empty list => []
6.Empty Map  => [:]

def a = 100;
if (a) {
    println("$a is Valid")
} else {
    println("$a is Invalid")
}
def b=0
if (b) {
    println("$b is Valid")
} else {
    println("$b is Invalid")
}
..............................................................................................
				  Operators
.............................................................................................

1.Arithmetic operators
2.Relational Operators
3.Logical Operators
4.BitWise operators
5.Conditional Operators
6.Object Operators
7.Regular Expression Operators
8.Spread Operator
9.Range Opeator
10.Spaceship Operator
11.Subscript operator
12.Safe index operator
13.Membership operator
14.identity operators
15.coercion operator
16.Diamond operator
17.call operator
..............................................................................................
					1.Arithmetic operators

-Binary operator
  Requires two operand
-Unary operator
  Requires one Operand

Binary Operator
+ - Addition
- - Substraction
* - multiplication
/ - division
% - remainder
** - power operator - groovy operator

println "Arthimetic operators"

def a = 10
def b = 20;

println "Addition ${a + b}"
println "Substraction ${a - b}"
println "Multiplication ${a * b}"
println "Division ${a / b}"
println "Remainder ${a % b}"
println "Power of  ${a**2}"
println "Unary + ${a++}"
println "Unary + ${++a}"
.............................................**************..................................
				  Assignment Operators
//single assignment
def a = 10;
def b = 20;
println "$a $b";
//multiple assignment : java style
int s = 1, d = 80;
def x = 1, y = 2;
println "$x $y";
//multiple assignment : groovy style
def (x1, y1, de) = [10, 20, 9];
println "$x1 $y1 $de";
//mixed data type in one line
def (status, today, counter) = [true, "02-02-19", 1];
println "$status  $today  $counter"

//extra values are left
def (one, two) = [1, 2, 3, 4, 5];
println "$one $two";

//lesser values but extra variable and its value is null
def (xy, xz, xa) = [1, 3];
println "$xy $xz $xa";
//def (name,age,city)//error
def (name, age, city) = []; //empty brackets, all variables gets null as default value
println "$name $age $city"
.............................................................................................
			Assignment and Artihmetic:
............................................................................................

 def a =90;
 def res = a + 1
 def a+=3

+=
-=
*=
/=
%=
**=		

//assignment and arthimetic
def qty = 100;
def qtyCounter = qty + 1;
println("QtyCounter $qtyCounter")
qtyCounter +=1 // short cut for the above
println("QtyCounter $qtyCounter")

..............................................................................................
		Relational Operators: The Result would be boolean
/////////////////////////////////////////////////////////////////////////////////////////////

== equal
!= not equal - different
< lessthan
> greater than
<= less than or equal
>= greater than or equal

def a = 10;
def b = 10;
println a == b;
println a < b;
println a <= b;
println a > b;
println a >= b;
println a != b;
////////////////////////////////////////////////////////////////////////////////////////
Logical Operators: boolean result
...........................................................................................

&&  - logical "and"
||  - logical "or"
!   - logical "not"

These operators works based on truth table

and
0 0  - 0
1 0  - 0
0 1  - 0
1 1  - 1

Or
0 0  - 0
1 0  - 1
0 1  - 1
1 1  - 1

!
0 - 1  
1  -0



def isActive = true;
def isEnabled = true;
println " && => " + isActive && isEnabled; //true
println " || => " + isActive || isEnabled; //true
println " !  => " + !isEnabled; //false

def name = ""   //false
def city = "Coimbatore";  //true
println name && city; //?

def start = 0; //0 false
def stop = 10; //10 true
println start || stop; // true

def isEmpty; //null
println isEmpty;
println !isEmpty
isEmpty = "hello"
println !isEmpty
..............................................................................................
///////////////////////////////////////////////////////////////////////////////////////////

Bitwise and bit shift operators:
.................................

Bitwise operators are used to maniuplate bits - based on 2's compliement theories.

& - bit wise and
| - bit wise or
~  - bitwise negation

bit shit operators

<<  -left shift
>> -right shift
>>> - right shift unsigned.
////////////////////////////////////////////////////////////////////////////////////////////
				Conditional Operators
............................................................................................

1.not operator - !
2.Tenary operator - ?:
3.Elvis Operator  - ?

Not Operator : (!)

Not operator is represented with an exclamation mark and inverts the result of underlying boolean expression

!true = false
!false = true
!''  = true

Tenary Operator:
  //Tenary operator

def a = 10
def b = 50
//compare and say some result
if (a == b) {
    println("A and B are equal")
} else {
    println("A and B are not equal")
}
//the above code can be simplified using tenary operator

(a == b) ? println("A and B are equal") : println("A and B are not equal")

def res = (a == b) ? "A and B are equal " : "A and B are not equal"
println(res)

//tenary with other booleans

def name = "Subramaian";
def response = name ? "Hello $name" : "Hello!"
println(response)

............................................................................................
				Elvis Operator
............................................................................................
The "Elvis operator" is a shortening of the ternary operator. One instance of where this is handy is for returning a 'sensible default' value if an expression resolves to false-ish

def a=0

 if a is true, print a's value , else assign our own default value.


Elvis operator is used to assign default values if a variable is false.
?: =>Elvis operator

//Elvis operator is used to assign default values if a variable is false.

def counter; //null
//if counter is false,then initalize 1 else the value of the counter
println counter ?: 1;


//!
def myvar = true;
println !myvar;
//?:
//where ever if ..else lader you can replace with ?:
def a = 10;
def b = 20;
if (a == b) {
    println "Equal"
} else {
    println "Not equal"
}
a == b ? println("Equal") : println("Not Equal");
def result = a == b ? "Equal" : "Not Equal";
println result
def name = "subramanian";
def found = name ? "Name Found $name" : "Name not Found"
println found;
//////////////////////
def price;
//Using tenary
println price ? price : 10;
//Using elivs
println price ?: 10

def totalPrice = price?:10 * 100;
println "Total Price $totalPrice"
..............................................................................................
			Regular Expression Operators
..............................................................................................

Pattern Operator : ~
~/pattern/ ->Pattern

//~Pattern operator
def pattern = ~/\d+/
println pattern instanceof Pattern

Find operator:=~

Alternatively to building a pattern, you can directly use the find operator =~ to build a java.util.regex.Matcher instance

=~ ->Returns Matcher Instance

def text="mytext"
//=~ Find operator which returns Matcher
def matcher = (text =~/\d+/);
println matcher instanceof Matcher; 


Match operator:
..............

 ==~ Matcher Operator : returns boolean
 !=~ Matcher Operator : returns boolean

import java.util.regex.Matcher
import java.util.regex.Pattern

//
def pattern = ~/\d+/
println pattern instanceof Pattern

def text="mytext 45 67"
//=~ Find operator which returns Matcher
def matcher = (text =~/\d+/);
println matcher instanceof Matcher;

// ==~ : match operator which returns boolean

def result =  (text ==~/\d+/)
println(result)
..............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////

                                          Conditional Strucutures
/////////////////////////////////////////////////////////////////////////////////////////////
def isActive = true;
if (isActive) {
    println "Active"
} else {
    println "Not Active"
}
def x = "hello";
def result = "";

switch (x) {
    case "foo":
        result = "foo value"
        break
    case "bar":
        result = "bar value"
        break
    case 122:
        result = "some numbers"
        break
    case true:
        result = "some boolean"
        break
    case Integer:
        result = "Integer value"
        break
    case ~/fo*/:
        result = "Regular expression value"
        break
    case Number:
        result = "Number value"
        break;
        default:
        result = "No match found"
        break;
}
println result;
..............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////
				Iterators - Loops
/////////////////////////////////////////////////////////////////////////////////////////////
for (int i = 0; i < 10; i++) {
    println i;
}
for (def i = 0; i < 10; i++) {
    println i;
}

def x = 0
def y = 5
while (y-- > 0) {
    x++
    println "Y $y"
}
println x;
//do ..while
def counter = 5;
def fact = 1;
do {
    fact *= counter--
} while (counter > 1)
println fact
.............................................................................................
Coding Challanges:
..................

Q:1.find even numbers from 0 to 1000 range.


Q.2.find Grade for given score

 score is greater than 95 - A

 80 tO 95 - Grade B

 60 to 80 -Grade C
 
 50 TO 60 - Grade D
 
 less THAN 50 - F 
............................................................................................
				Groovy Scripting - methods
...........................................................................................	-collection of variables and methods(functions).

How scripts are working?

 When we write script , groovy creates a class "ScriptClass" , will have main method and run method.
 The name of the script file  will go as name of the script class name.

eg:

Written by you?

 HelloWorld.groovy

 println "Hello Script"

Groovy will write like below

class HelloWorld extends Script{

    //method called run
    def run(){
      println "Hello Script"
   }
 
 static void main(String[]args){
  
      InvokerHelper.runScript(HelloWorld,args)
 }

}
methods:
........

-methods are going to group biz/application logic.


Syntax:

 1.static typed syntax ; looks like a java syntax

   returntype methodName(args){
     //method body
     return statement
   }
   void sayHello(){ 


   }
2. dynamic typed syntax

    def methodName(args){
      //method body
    }


eg;
Static Typed:Java Style
//methods : group biz logic

//static typed methods - style of static typed methods
//method declaration
void sayHello() {
    println("Hello Java Style")
}
//method invocation
sayHello();

//parameters and args

//name, message are args
void sayWelcome(String name, String message) {
    println("$message $name")
}

sayWelcome("Subramanian", "Hello") // parameters
//sayWelcome("Subramanian",34) // //wrong

//if method returns values
int add(int a, int b) {
    int c = a + b
    //return a + b // you are sending output to outside method
    return c
}

int result = add(10, 10) //  calling method
println("The add Result is $result")

//Return string
String getName() {
    return "Subramanian"
}

String name = getName()
println(name)
//biz logic with return
boolean login(String name, String password) {
    if (name == "admin" && password == "admin") {
        return true
    }
    return false
}

boolean isValid = login("admin", "admin")
if (isValid) {
    println("Login success")
} else {
    println("Login Failed")
}
//using tenary operator
isValid ?  println("Login success") :  println("Login Failed")

login("foo", "foo") ? println("Login success") : println("Login Failed")
.............................................................................................
			Dynamic Typed methods-parameters and args
.............................................................................................
//Groovy Style methods : dynamic typed

def sayHello(){
    println("Hello Groovy method")
}
sayHello()
//args and parameters : args are style strong typing
def sayWelcome(String name,String message){
    println("$message $name")
}
sayWelcome("Subramanian","Hello")
//args and parameters with dynamic typed
def sayHai(def name){
   println("Hai $name")
}
sayHai("Subramanian")
//with def keyword
def doStuff_(def myvar){
    println("My Variable value is $myvar")
}
//without def keyword also valid
def doStuff(myvar){
    println("My Variable value is $myvar")
}
//you can pass any type of value
doStuff("I am passing string")
doStuff(1000)
doStuff(10.78)
doStuff(true)
doStuff() //no value means null

///drawbacks or trade off dynamic typed parameters
def calculate(a,b){
    def c = a * b
    println("The Result is $c")
}
calculate(10,10)
calculate(34.68,89.90)
//calculate(true , false) // you will get runtime error
..............................................................................................
			  How to fill with default values
//Groovy allows to skip parameters

def sayHello_(String name) {
    println("name $name")
}

def sayHello(name) {
    println("name $name")
}
//passing parameters
sayHello("Subramanian")
//skip parameters
sayHello()

//what if i dont pass value, how to replace null with some meaningful values
//default values
def sayHai(name = "Foo") {
    println("Hai $name")
}

sayHai("Ram")
sayHai()

def add_(int a = 0, int b = 0) {
    int c = a + b
    println("C is $c")
}

def add(Integer a = 0, Integer b = 0) {
    int c = a + b
    println("C is $c")
}

add(1, 3)
add()
//add("test")
............................................................................................
				Variable Args - VarArgs
............................................................................................

what if i want a method, that method must take n-number of args.
 What if i pass more parameters, but i have less args.



// i have method , but i has less args, dynamically i pass more parameters : VarArgs

def log(String ...args){
    println args
}
log('This is warning')
log('This is warning','This is error','This is something')
............................................................................................
					
				Method Return values and types
.............................................................................................

type method(){}

def method(){}

String sayHello() {
    return 'Hello';
}

//def return values
//def return values

def sayHello() {
    return "Hello"
}

println(sayHello())

def getIntValue() {
    return 100
}

println(getIntValue())

def calculate_(int a = 0, int b = 0) {
    return a + b  // expression
}

def calculate(int a = 0, int b = 0) {
    return "The result is ${a + b}"  // expression
}

println(calculate(13, 90))

//without return statement indicates that method by default returns

String getName_() {
    def firstName = 'Subramanian'
    def lastName = 'Murugan'
    def fullName = "$firstName $lastName"
    //old style
    return fullName
}

String getName() {
    def firstName = 'Subramanian'
    def lastName = 'Murugan'
    def fullName = "$firstName $lastName"
}

println(getName())

def getFullName() {
    def firstName = 'Subramanian'
    def lastName = 'Murugan'
    def fullName = "$firstName $lastName"
}

println(getFullName())
//return values with expressions and hardcoded values

def getPrice() {
    //here 100 to be returned
    100
}

println(getPrice())

def getTotalPrice() {
    def qty = 100
    def price = 900
    qty * price
}

println(getTotalPrice())

def iterate() {
    for (def i = 0; i < 10; i++) {
        println("I $i")
    }
}

def value = iterate()
println("Returned value is $value")
//empty method
def empty() {

}

def emptyResult = empty();
println("Empty Method Result $emptyResult")

//logic
def login(String name = "", String password = "") {
    (name == "admin") && (password == "admin")
}

login("admin", "admin") ? println("Login is Success") : println("Login is failed")
login("admin", "foo") ? println("Login is Success") : println("Login is failed")

//Receive the parameter and return the same
def getStockvalue(stock) {
    stock
}
println(getStockvalue(100))
.............................................................................................
			 Object oriented Programming and Implementation
.............................................................................................

Any PL deals two things

1.Data
2.methods/functions

What can be data?
 Numbers,Characters,booleans

You can consider any thing as data.

Program is collection of instructions (variables,expressions,literals,methods)

can you consider method as data?

 You may be thinking, No, data means need to be stored inside variable
eg:
 int a=10

 can i store method inside variable? 
   yes or no. 
 Yes -that leads functional programming
.............................................................................................

OOP - is also one of the style of programming.

According to oop, data and methods are encasulated under single unit called "Object"

methods never be without data, data never be without methods

methods operate on data.

why methods operate on data?
   They want to change the data.
..............................................................................................
				Object oriented Concepts
.............................................................................................
 
  data + methods

Core concepts:
1.State
   Data
2.Behaviour
  methods

1.Abstraction
2.Encapsulation
3.Modularity
4.Hierachy
5.Typing
6.Persistency
7.Concurrency
.............................................................................................
				  Abstraction
.............................................................................................

What is abstraction?
   "Focus what is necessary ,Dont focus what is not necessary"

The real world object may have been associated with million properties, but all properties not necessary for all types of domains.

Filtering data according to domain which is called abstraction.

Abstraction helps to capture right data for right domain.

How to apply /map/ implement abstraction in programming languages?

1.Compile Time/Source code

 =>classes


2.Runtime/Compiled  Code

 =>Object

What is class ?

  It is container/unit to capture domain data.

Task: Caputure employee details.

Employee.groovy

package com.airbus.oo.abstraction

class Employee {
    //state -data 
    int id
    String firstName
    String lastName
    double salary
    String department
    String role
}


int   a =      10;
 |    |         |
Type variable  value

//Object Creation and syntax

Employee employee = new     Employee()
 |         |         |         |
Type     Variable  keyword  constructor call

Type classification:

1.primitives - int,float...
2.Reference type - Object type
  Employee....

Types of variables

primtive variables - variables are declared with primitive types
Reference variables -variables are declared with Reference types


Object Properties
    int id
    String firstName
    String lastName
    double salary
    String department
    String role

in order to access object properties,Groovy Offers object access operator.

"." -  dot operator /  member access operator

How to use this operator

 referencevariable.property
eg:
 employee.id

import com.airbus.oo.abstraction.Employee

//Create Object

//Static typed way of creating Object
Employee employee = new Employee()
//access object properties
println("Employee Id : ${employee.id}")
println("Employee FirstName  : ${employee.firstName}")
println("Employee LastName : ${employee.lastName}")
println("Employee Salary : ${employee.salary}")
println("Employee Deparment : ${employee.department}")
println("Employee Role : ${employee.role}")

//Dynamic typed way of creating object
def emp = new Employee()
println("Employee Id : ${emp.id}")
println("Employee FirstName  : ${emp.firstName}")
println("Employee LastName : ${emp.lastName}")
println("Employee Salary : ${emp.salary}")
println("Employee Deparment : ${emp.department}")
println("Employee Role : ${emp.role}")
.............................................................................................
				   Object
.............................................................................................

What is Object?

There are two views:

1.DOMAIN View /Realworld View
  
Object is tangable enity,you should able touch , feel, it.

Can you describe "air" as object?
 Yes,No
can you describe "god" as object?   
  Some people say there is god
  Some people say there is no god
Which is true?

According to grady, "Object can be any thing/every thing,but that should be in the problem domain"

eg:
I am building software for weather forecasting system, in this system which primary entity?
 "Air"
According to weather forecasting system,"Air System".

I am building banking software , in this domain "Air is not Object". 

..............................................................................................

object oriented analysis and design:

Process:
1.collect requirement - functional req
2.design the system based on requirement
  2.1.Identify the objects 
      Banking 
      	-Customer
        -Account 
        -Loan
3.Apply abstraction
   Customer - customerId/AccountNo, firstName,lastName,dob,mobileNo....

4.Start coding 
  Abstraction - classes

class is a blue print of realworld Object
.

2.Program View    

 In order to understand what is object in groovy/java?

You need to understand some internals of JVM.

What is JVM?
   Process which hosts groovy/java apps


 Employee emp = new Employee() ; // Object creation /Object instantation

Object is memory, dynamic memory, allocated inside heap segment of JVM.

new - operator , memory allocation 

Employee employee=new Employee() - function call,method call
  |         |
Type        memory Handler - reference(pointer) variable

..............................................................................................
				 Object = State(data)  and Behaviour(methods)
..............................................................................................

How state is changed via methods?

//src/Calculator.groovy
package com.airbus.oo.abstraction

class Calculator {
    //state
    int result
    int a, b
    //methods
    int add(int a, int b) {
        this.a = a
        this.b = b
        this.result = a + b
        return result
    }
}

src/CalculatorMain.groovy

import com.airbus.oo.abstraction.Calculator
def calc= new Calculator();
def res = calc.add(10,10)
println("The result is $res")
.............................................................................................
Reference variable:

 Variable which points the address of object

 def calc= new Calculator();
here calc is reference variable

Types of reference variable:

1.custom reference variable

 def calc= new Calculator();
here calc is reference variable

2.implicit reference variable
 "this" -  implicit reference variable which points the object itself 
 "super" - implicit reference variable which points the super object

Types of variables;
...................

Types of variables can be classified according to various category.

1.based on data type.
  1.1.reference variable ... Employee,Calcuator...
  1.2.primtive variables - int,float...

2.based on where we have declared variable

  2.1.inside class
	with any type(reference/primitive),inside class are called as "instance variables"
 eg :
      int a;
      String str;

  2.2.inside class with one keyword(static)
       with any type(reference/primitive),inside class with static keyword are called as "class variables/static variables"
      static int a 
      static String str


  3.1.inside method
      def doStuff(int b){
         int a =0
      }
   here a and b are part of method -  called as "local variables"
   
 
When to use "this"?

 int add(int a, int b ){ //local variables {
        this.a = a // local variable a's value is assigned to instance variable
        this.b = b
       // a=a //lvalue requ
        this.result = a + b
        return result
    }

 here in order to avoid confusion to the compiler that lefside is instance variable and right side is local variable


package com.airbus.oo.abstraction

class Calculator {
    //state
    //instance variables
    int result
    int a, b //instance
    //methods
    int add(int a, int b ){ //local variables {
        this.a = a // local variable a's value is assigned to instance variable
        this.b = b
       // a=a //lvalue requ
        this.result = a + b
        return result
    }
    //groovy syntax
    def multiply(a=0,b=0){
        a*b
    }
}

import com.airbus.oo.abstraction.Calculator


def calc= new Calculator();
def res = calc.add(10,10)
println("The result is $res")

println(calc.multiply(10,10))
println(calc.multiply())


Note: all method syntax discussed as part of script, can be used inside class directly.
..............................................................................................

classes are in java language:

1.class is used to represent object template.
2.class contains variables and methods
3.class can also contain another class,interfaces ; inner classes
4.Every java program must start with class definition only.
5.Every program can have mulitple java classes , but recommended is only one class per   file/program
6.Every java program must have main method.

Objects:

1.Runtime representation of class we call "Object"
2.Object means , memory representation of class.
3.We can create more objects from a single class, but each object has its own memory address
4.Object is pointed by a variable called "reference variable" ; pointer to object
5.object contains methods, and variables called instance members.
............................................................................................
				 Groovy Beans
............................................................................................

Java Bean:
  Java Object is other wise called as Java Bean

-It is a standard  or spec for declaring a class and create object.

Java Bean Spec:
...............
 How to declare class,fields(variables, methods)

How to declare state(variables), and how to initalize them?

1. inside class - hardcoded values

package com.airbus.oo.objectinit;

public class Product {
    //state
    int id =1;
    String name="Phone";

}
   Product product = new Product();
        System.out.println(product.id);
        System.out.println(product.name)

2. after object creation using reference variables
public class Product {
    int id;
    String name;
}
        Product product = new Product();
        //after object creation
        product.id = 1;
        product.name = "Phone";

        System.out.println(product.id);
        System.out.println(product.name);

3. during object creation using "constructors"

What is constructor?
   It is special method like other methods.

Features constructor:

1.constructors are only used for initalization of state , not for holding biz logic
2.constructors name should match class name.
3.constructors may take arg 
4.constructors never return any value.
5.we can have many constructors inside single class to initalize the objects in different ways.

package com.airbus.oo.objectinit;

public class Product {
    //state
//    int id =1;
//    String name="Phone";
    int id;
    String name;

    //no arg - no arg constructor
    public Product() {
        this.id = 0;
        this.name = "defaultProduct";
    }

    //with id and name
    public Product(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Product(int id) {
        this.id = id;
        this.name = "defaultProduct";

    }

    public Product(String name) {
        this.name = name;
        this.id = 199;
    }
}
package com.airbus.oo.objectinit;

public class ObjectInitMain {
    public static void main(String[] args) {
//        Product product = new Product();
//        System.out.println(product.id);
//        System.out.println(product.name);

//        Product product = new Product();
//        //after object creation
//        product.id = 1;
//        product.name = "Phone";
//
//        System.out.println(product.id);
//        System.out.println(product.name);

        //using constructor
        Product product = new Product();
        System.out.println(product.id);
        System.out.println(product.name);
        //arg constructor
        Product product1 = new Product(20,"Books");
        System.out.println(product1.id);
        System.out.println(product1.name);

        Product product2 = new Product(30);
        System.out.println(product2.id);
        System.out.println(product2.name);

        Product product3 = new Product("Food Items");
        System.out.println(product3.id);
        System.out.println(product3.name);
    }
}
..............................................................................................
			Object state initalization standards - java Bean standards
.............................................................................................

=> state variables should not be accessed outside class directly

       Product product = new Product();
       //which is not standard way of accessing variables
       product.id = 1;
       product.name = "Phone";

state variables must be accessed via "accessor and mutatators - setters and getters"

Setters and getters:
=>methods are used to intialize and read instance variables.

Setters Rules:

1.should start with public
public 
2.method must have void return type
3.method name must start with "set" convention
 public void set
4.method name must be name of the instance variable
  public void setId
4.method name must be camel Case - smallLetterUpperCase
 public void setId()

5.method must take arg which must match instance variable.
public void setId(int id){
        
    }
6.inside that method you have to initalize the instance variable using this keyword

7.For every instance variable we must have "setter"

8.All instance variables must be marked "private"


getters : to read value

1. start with public 
2. method must return have type -  type of variable
3. start with "get" + variable Name ->camelCase
4. must not have any args
5. must return instance variable

package com.airbus.oo.objectinit;

public class Product {
    //state
//    int id =1;
//    String name="Phone";
    private int id;
    private String name;

    //no arg - no arg constructor
    public Product() {
        this.id = 0;
        this.name = "defaultProduct";
    }

    //with id and name
    public Product(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Product(int id) {
        this.id = id;
        this.name = "defaultProduct";

    }

    public Product(String name) {
        this.name = name;
        this.id = 199;
    }

    //setters and getters -are used to read and write data.
    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getId(){
        return id;
    }
    public String getName(){
        return name;
    }

}
package com.airbus.oo.objectinit;

public class ObjectInitMain {
    public static void main(String[] args) {
//        Product product = new Product();
//        System.out.println(product.id);
//        System.out.println(product.name);

//        Product product = new Product();
//        //after object creation
//        product.id = 1;
//        product.name = "Phone";
//
//        System.out.println(product.id);
//        System.out.println(product.name);

//        //using constructor
//        Product product = new Product();
//        System.out.println(product.id);
//        System.out.println(product.name);
//        //arg constructor
//        Product product1 = new Product(20,"Books");
//        System.out.println(product1.id);
//        System.out.println(product1.name);
//
//        Product product2 = new Product(30);
//        System.out.println(product2.id);
//        System.out.println(product2.name);
//
//        Product product3 = new Product("Food Items");
//        System.out.println(product3.id);
//        System.out.println(product3.name);

        Product product = new Product();
        product.setId(1);
        product.setName("Phone");
        System.out.println("Id " + product.getId());
        System.out.println("Name " + product.getName());
    }
}
..............................................................................................

package com.airbus.oo.objectinit;

public class Patient {
    private int id;
    private String name;
    private String city;
    private String mobileNo;
    private String email;

    public Patient() {

    }

    public Patient(int id, String name, String city, String mobileNo, String email) {
        this.id = id;
        this.name = name;
        this.city = city;
        this.mobileNo = mobileNo;
        this.email = email;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getMobileNo() {
        return mobileNo;
    }

    public void setMobileNo(String mobileNo) {
        this.mobileNo = mobileNo;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    //setters and getters

    //constructors
}

Patient patient = new Patient();
        patient.setId(1);
        patient.setName("Ram");
        patient.setCity("Coimbatore");
        patient.setEmail("ram@gmail.com");
        patient.setMobileNo("99999999");
        System.out.println(patient.getId() + " " + patient.getName() + " " + patient.getEmail());
    
..............................................................................................
/////////////////////////////////////////////////////////////////////////////////////

setters vs constructors:

Both recommened:

1.Use setter once object is created. lazy initalization
2.Use constructor during object creation; Eagar intialization
//////////////////////////////////////////////////////////////////////////////////////////
			Groovy and Object Oriented Programming

1.Groovy uses Groovy Standards
   ->Groovy Bean standards

1.declare class
2.create object

package com.airbus.oo.groovybeans

//by default groovy class is public classes
class Message {
    //state  // here variables must not be marked private,
    // the reason groovy generates , setters and getters for us
    String message
    String to
    String from
    //can i declare the variables using def keyword : yes, but not recommended
//    def message
//    def to
//    def from
}
import com.airbus.oo.groovybeans.Message

def msg = new Message()
//setters
msg.message = "Hello" //groovy interally calls message.setMessage()
msg.to = "John"
msg.from = "Subramanian"
//getters
println("Message ${msg.message} ${msg.to} ${msg.from}")
.............................................................................................
			  Groovy Beans and Constructors
.............................................................................................

Groovy generates even constructors for us , you dont need to have constructors.

Constructors are generated based on 'key:value' pair.

//key:value ; key-instance variable; value ; variable value
def msg1 = new Message(message: "Hai", to: "Foo", from: "Bar")
println("Message ${msg1.message} ${msg1.to} ${msg1.from}")

def msg2 = new Message(message: "welcome")
println("Message ${msg2.message} ${msg2.to} ${msg2.from}")
.............................................................................................
				Object Operators:
.............................................................................................

1.Direct field access operator:

 It is used to access fields

field:
  - It is an instance variable declared inside class


"." - field access operator.
    internally triggers getter
".@" - field access operator.
    if you want to access without getter.



class Person {
    int id;
}

def person = new Person(id:100);
println person.id;

person.id ----calls person.getId() => which calls getter method

println person.@id -Which access id property directly
.............................................................................................
				Default Values for Object
.............................................................................................

values not initalized for an instance variable via  hardcoded inside class or even via setters or constructors or outside class.


if you declare any variable whether it is primitive or reference inside a class.
  Those variables are called as "instance variables".

if you declare any variable whether it is primitive or reference inside a class with static keyword.
  Those variables are called as "class  variables". static String varName=value

Any variable has default value:

integer family
  0
floating family
 0.0
boolean family
 false
Reference types - String,Employee....
 null

class Person {
    int id;
    String name;
    boolean  isActive;
    double pointers;

}

def person = new Person();
println person.id;
println person.@id
println person.name
println person.isActive
println person.pointers

output:

0
0
null
false
0.0
..............................................................................................
				    null

What is null?
    "It is also one of the value".
It is assigned to a variable and its type should be reference type.
null is assigned for an reference variable when the variables does not point valid memory address

if you access any property based on null, "The jvm will throw the error called "NullPointerException", Your app will stop functioning.
  

package com.airbus.oo.groovy.nullvalues

class Product {
    int id
    String name
}
import com.airbus.oo.groovy.nullvalues.Product


//product variable here not pointing any valid memory address
Product product=null
println(product.id)

//here you have initalized the variable called "product1 with valid Memory address"
Product product1 = new Product()
product1.id =1
println(product1.id)

Caught: java.lang.NullPointerException: Cannot get property 'id' on null object
java.lang.NullPointerException: Cannot get property 'id' on null object
	at NullMain.run(NullMain.groovy:6)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)

...........................................................................................
				How to handle null in groovy
...........................................................................................

How to safely avoid NullpointerException?

Groovy provides an operator called 

 "safe navigation operator":
      ?.

eg:
  person1?.name


import com.airbus.oo.groovy.nullvalues.Product


//product variable here not pointing any valid memory address
Product product = null
//println(product.id)
//safe navigation operator will safely handle null errors
//def res = product?.id
//println("Result ${res}") //null
//Product product = new Product(id:1000)

if (product?.id) {
    println(product.id)
} else {
    println("No Product Id")
}
//using tenary we can give default values

println(product?.id ? product.id : 10)

//using elvish we can give default values
println(product?.id ?: 10)


//here you have initalized the variable called "product1 with valid Memory address"
Product product1 = new Product()
product1.id = 1
println(product1.id)
..............................................................................................
				Method Pointer Operator
.............................................................................................
The method pointer operator (.&) can be used to store a reference to a method in a variable.
in order to call it later.

package com.airbus.oo.groovy.methodreference

class Greeter {
    def sayHello(){
        "Hello"
    }
}
import com.airbus.oo.groovy.methodreference.Greeter

def greeter= new Greeter()
//method is called
println(greeter.sayHello()) //direct method call

//method can be stored inside variable and later it can be called.
def hai = greeter.&sayHello
println(hai())
.............................................................................................
			 Object DeStructuring

In General How object properties are accessed?

referencevariable.propertyName 

 
Anthoer way of  Extracting object properties.

Rules;
-in order to implement object destructuring, getAt method must be given
-returns variable type /def 
-takes index as arg
-write a logic to assign index  based properties
package com.airbus.oo.groovy.objectdestructuring

class Coordinates {
    double latitutde;
    double longitude;
    //object destructing api
    def getAt(int idx) {
        if (idx == 0) latitutde
        else if (idx == 1) longitude
        else throw new Exception("Property not found")
    }
}

import com.airbus.oo.groovy.objectdestructuring.Coordinates

def coordinate = new Coordinates(latitutde: 12, longitude: 45)
println(coordinate.latitutde)

def (lat, lng) = coordinate
println("$lat $lng")
.............................................................................................
				Encapsulation
.............................................................................................

It is a feature of OO, talks about , how to prevent code sharing.


 It is a feature of OO, talks about , how to prevent code sharing.

What is code :
  collection of classes
  class is having fields and methods, constructors

In large application , we create many classes, we need to set some of rules how to share code.


How to restrict code access?

 java/groovy provides keywords 
   -private,default,public,protected

These keywords are used to control code sharing

 private - means no body can access expect the current class
 private is used for instance variables and instance methods.


How to restrict code access?

 java/groovy provides keywords 
   -private,default,public,protected

private - means no body can access expect the current class
 private is used for instance variables and instance methods.

In groovy:
 private variables are not recommended to be treated as object fields.

if you declare private, groovy wont generate setter and getters.
private variables are by default converted into public.
private methods are by default converted into public.


if you tell, no setters and getters will be generated, if dont want setter and getter 
you use public keyword.

default: no modifer is told

     String city; - public 

protected: used inside inheritance


classes are by default public without public keyword

User.groovy  - scope is public
class User{}

User.java
class User {} - scope is default-package level
..............................................................................................
				  Hierachy

common Code sharing across the class and objects

Types of hierachy

1.has-a - composition
2.is-a - inheritance



HAS-A
package com.airbus.oo.groovy.hasa

class Address {
    String street
    String doorno
    String city
    String state
    String zipcode
}
package com.airbus.oo.groovy.hasa

class Customer {
    int id
    String firstName
    String lastName
    //has-a
    Address address

}
package com.airbus.oo.groovy.hasa

class Employe {
    String empId
    String empName
    //has-a
    Address address

}

//
import com.airbus.oo.groovy.hasa.Address
import com.airbus.oo.groovy.hasa.Customer

def address = new Address(doorno: "10", street: "10th street", city: "Coimbatore", state: "TN", zipcode: "6632323")
def customer = new Customer(id: 1, firstName: "Subramanian", lastName: "Murguan", address: address)
println("${customer.firstName} ${customer.address.city}")

//another syntax to attach objects
def customer1 = new Customer(id: 1,
        firstName: "Subramanian",
        lastName: "Murguan",
        address: new Address(doorno: "10", street: "10th street", city: "Coimbatore",
                state: "TN", zipcode: "6632323"))
println("${customer1.firstName} ${customer1.address.city}")
.............................................................................................
				  Inheritance - IS - A 
...........................................................................................................................................................................................

How to implement is-a(inheritance) in groovy?

1.classes
  concrete class
  abstract class
2.interfaces
   similar to classes
3.trait
   similar to interfaces


How to define parent and child? how to share code(data + method)

Data sharing:
.............


concrete class: normal classes

Parent class,Super class

package com.airbus.oo.groovy.isa

class Person {
    String firstName
    String lastName
}

//child class,dervied class,sub class

package com.airbus.oo.groovy.isa

//Employee is child of Person
class Employee extends Person {
   int empId
}

import com.airbus.oo.groovy.isa.Employee

def emp = new Employee(empId: 1,firstName:"Subramanian",lastName: "Murugan" )
println("${emp.empId} ${emp.firstName} ${emp.lastName}")

protected;
  It is modifier used for protecting variables and methods, can be used only with in the same class or its child class only.

package com.airbus.oo.groovy.isa

class Person {
    //protected means the variables will be availble only within this class or inside class class
    protected String firstName
    protected String lastName
}
.............................................................................................
				Method Sharing  -Typing
.............................................................................................

Parent class:
package com.airbus.oo.groovy.isa.typing

//base class
class Vehicle {
    //method
    def startEngine() {
        "Vehicle engine starts";
    }
}
package com.airbus.oo.groovy.isa.typing

class Car extends Vehicle{
}

import com.airbus.oo.groovy.isa.typing.Car

def car = new Car()
println(car.startEngine())

output:
Vehicle engine starts
.............................................................................................
				 Polymorphism
.............................................................................................

1.Runtime Polymorphsim

Overriding: Giving different different algorthim for a method in dervied class

 The over ride the base class method in dervied class.

When ever we call a method , the Runtime sees a dervied class only. if method found in the 
dervied class, then that method will be called.

package com.airbus.oo.groovy.isa.typing

//base class
class Vehicle {
    //method
    def startEngine() {
        "Vehicle engine starts";
    }
}


package com.airbus.oo.groovy.isa.typing

class Car extends Vehicle{
    //override method
    def startEngine() {
        "Car engine starts";
    }
}
package com.airbus.oo.groovy.isa.typing

class Bus extends Vehicle{

    //overriding
    def startEngine() {
        "Bus engine starts";
    }
}

import com.airbus.oo.groovy.isa.typing.Bus
import com.airbus.oo.groovy.isa.typing.Car

def car = new Car()
println(car.startEngine())

def bus = new Bus()
println(bus.startEngine())

output:
Car engine starts
Bus engine starts


Points:

1. if the method is not found in the child class, parent class method is used
2. if the method is foun in the child class, then child method is used.
.............................................................................................
			 The Type(data type and inheritance).
		        (How dynamic typing is working under hood)
				(How "def" keyword works)
..............................................................................................
			
How Static Typing works?

package com.airbus.oo.groovy.isa.typing;

public class Animal {
    public String eat() {
        return "Animal eats both veg and meat";
    }
}
package com.airbus.oo.groovy.isa.typing;

public class Cat extends Animal{
    @Override
    public String eat() {
        return "Cat drinks milk";
    }
}
package com.airbus.oo.groovy.isa.typing;

public class AnimalMain {
    public static void main(String[] args) {
        //Object creation syntax
        //syntax -1
        Cat cat  =new Cat();
        System.out.println(cat.eat());
    }
}

Reference variable declaration syntax:

1.Type of the variable can be Same type of Object

Cat cat = new Cat()

2.The type of variable can be super type(Parent Type)

Animal cat = new Cat()
   Animal cat1 = new Cat();
   System.out.println(cat1.eat());

    "The type of variable can be the same type or super type".

..............................................................................................

Super Type and Methods in the derived type
...........................................

package com.airbus.oo.groovy.isa.typing;

public class Cat extends Animal{
    @Override
    public String eat() {
        return "Cat drinks milk";
    }
    //this is cat specific method
    public String huntRats(){
        return  "Cat Can Hunt rats";
    }
}
 Animal cat1 = new Cat();
        System.out.println(cat1.eat());
        cat1.huntRats();

Here you will get compile time error:
   "Cannot resolve method 'huntRats' in 'Animal'"
	
Why this error?

There are two phases in the code?

1.compile time
  compiler checks the code during compile time whether all expressions are valid.

expressions are :
 int a =10; here compiler verifies the whether is is compatiable to a.

 Animal cat  = new Cat();
 cat.huntRats(); here compiler verifies the whether this method part of "type-Animal"
  "Whether this method is available in the Animal class or not", if not then compile time error

how to fix this compile time error?
 
 byte b =(byte)1000;
 we need to apply type casting

Cat catTemp = (Cat)cat1;
catTemp.huntRats();

2.runtime
 
 During runtime, the jvm looks always right side(objects), method invocations are happing objects.
..........................................................................................

public class Animal {
    public String eat() {
        return "Animal eats both veg and meat";
    }
}

Look at this code, do you think that , here Animal has any super class?
 
you may tell , no. but there is default super class called "java.lang.Object" / groov.lang.Object"

Every class in java and groovy has super most class is Object

package com.airbus.oo.groovy.isa.typing;

public class AnimalMain {
    public static void main(String[] args) {
        //Object creation syntax
        //syntax -1
        Cat cat  =new Cat();
        System.out.println(cat.eat());
        //syntax 2:
        Animal cat1 = new Cat();
        System.out.println(cat1.eat());
        Cat catTemp = (Cat)cat1;
        System.out.println(catTemp.huntRats());

        //Syntax 3:
        Object cat3 = new Cat();
        Cat cat3Temp = (Cat)cat3;
        cat3Temp.eat();
        cat3Temp.huntRats();

    }
}
.............................................................................................
				How groovy achives dynamic typing


def variable = new AnyClass();
      |
Object variable =new AnyClass();
Groovy writes type casting code for us.
..............................................................................................

"super"
   -It is variableName
   -It POints the Object
   -It points the Parent Object.
   -super variable is created during object creation, points Parent always.
  -every object has hidden implicit this pointer.

package com.airbus.oo.groovy.isa.typing

class Car extends Vehicle{
    //override method
    def startEngine() {
        "Car engine starts" + super.startEngine()
    }
}
.............................................................................................

2.Compile time polymorphism

 Compile time polymorphism is implemented using same type of reference variable.

Overloading:

 Having multiple copy of the same method with different parameter.

Types of Compile time :

1.method overloading
2.constructor overloading
3.operator overloading


package com.airbus.oo.groovy.isa.typing.overriding

class Calculator {
    //different copy of the methods
    //overloading
    def add(int a = 0, int b = 0) {
        a + b
    }

    def add(int a, int b, int c) {
        a + b + c
    }
}

import com.airbus.oo.groovy.isa.typing.overriding.Calculator

def calc = new Calculator()
println(calc.add(10,10))
println(calc.add(3,8,9))
............................................................................................

package com.airbus.oo.groovy.isa.typing.overloading

class Person {
    int id
    String name

}
//constructor overloading
def person = new Person(id: 1, name: 'Test')
def person2 = new Person(id: 1)
def person3 = new Person(name: 'test')
..............................................................................................
				interfaces,abstract classes, trait
.............................................................................................


Interfaces:

 -interfaces are classes;
 -interfaces can have abstract methods.

abstract method:
 no implementation is provided. implementation provided by implementators who inherits the interfaces.

  interfaces are used to share common code across multiple different family of classes
  classes are used to share common code single family of classes


package com.airbus.oo.groovy.isa.interfaces

interface Flyable {
    //only declaration
    String fly()
}
package com.airbus.oo.groovy.isa.interfaces

class Airplane implements Flyable{
    @Override
    String fly() {
        return "AirPlane is flying"
    }
}

package com.airbus.oo.groovy.isa.interfaces

class Bird implements Flyable {
    @Override
    String fly() {
        "Bird is flying"
    }
    //extra method
    String buildNest(){
        "Bird building Nest"
    }
}

import com.airbus.oo.groovy.isa.interfaces.Airplane
import com.airbus.oo.groovy.isa.interfaces.Bird
import com.airbus.oo.groovy.isa.interfaces.Flyable

def flyBehaviour = null
//Flyable flyBehaviour =null
//with Bird
flyBehaviour = new Bird()
println(flyBehaviour.fly())
println(flyBehaviour.buildNest())
//with AirPlane
flyBehaviour = new Airplane()
println(flyBehaviour.fly())
............................................................................................
				Types of Inheritance

1.single inheritance 
    one class can inherit only one class
    groovy/java does not support multiple classes in heritance

 class A extends B,C - invaild

2.multiple inheritance
   if you want to implement multiple , via interfaces

  class A implements D, E {

}

package com.airbus.oo.groovy.isa.interfaces

interface Eatable {
  String eat()
}

package com.airbus.oo.groovy.isa.interfaces

class Bird implements Flyable ,Eatable {
    @Override
    String fly() {
        "Bird is flying"
    }

    @Override
    String eat() {
        return "Bird eats nuts"
    }
//extra method
    String buildNest(){
        "Bird building Nest"
    }
}

def flyBehaviour = null
//Flyable flyBehaviour =null
//with Bird
flyBehaviour = new Bird()
println(flyBehaviour.fly())
println(flyBehaviour.eat())
println(flyBehaviour.buildNest())
//with AirPlane
flyBehaviour = new Airplane()
println(flyBehaviour.fly())
............................................................................................
				Abstract class

Abstract class   =interface + normal class

 Abstract class contains abstract methods(declaration) and with implmentations

package com.airbus.oo.groovy.isa.abstractclasses

abstract class Animal {
    //declaration
    abstract String eat()
    //implementation
    String saveAnimals(){
        "Save Animals from Hunters"
    }
}

package com.airbus.oo.groovy.isa.abstractclasses

class Tiger extends Animal{
    @Override
    String eat() {
        return "Tiger eats meat"
    }
}
package com.airbus.oo.groovy.isa.abstractclasses

class Cow extends Animal {
    @Override
    String eat() {
        return "Cow eats grass"
    }
}
import com.airbus.oo.groovy.isa.abstractclasses.Cow
import com.airbus.oo.groovy.isa.abstractclasses.Tiger

def animal = null
animal = new Tiger()
println(animal.eat() + " " + animal.saveAnimals())

animal = new Cow()
println(animal.eat() + " " + animal.saveAnimals())
............................................................................................
				Trait - Advanced Interfaces
............................................................................................

What is trait?
 Trait is similar as interface but very advanced interfaces.

drawbacks of interfcases

1.interfaces cant have implementation; but this feature added in java 8.


Traits are a structural construct of the language which allows

 -composition of behaviours
 -runtime implementation of interfaces
 -overriding
 -supports static typing/compilation
..............................................................................................

Simple Trait:
package com.airbus.oo.groovy.isa.traits

trait Flyable {
    //method implemenation
    String fly() {
        'I am flying'
    }
}
package com.airbus.oo.groovy.isa.traits

class Bird implements Flyable{
}

import com.airbus.oo.groovy.isa.traits.Bird
import com.airbus.oo.groovy.isa.traits.Person

def bird = new Bird()
println(bird.fly())
...........................................................................................

package com.airbus.oo.groovy.isa.traits


trait Greetable {
    abstract String name();
    String greeting() {
        "Hello ${name()}"
    }
}

package com.airbus.oo.groovy.isa.traits

class Person implements Greetable{
    @Override
    String name() {
        return "Subramanian"
    }
}
def greetings= new Person();
println(greetings.greeting())

........................................................................................
			 Dynamic binding of trait with classes

if you want to attach trait with class there are two

Way -1 : declare and attach via implements

trait Greetable {
    abstract String name();
    String greeting() {
        "Hello ${name()}"
    }
}
class Person implements Greetable{
    @Override
    String name() {
        return "Subramanian"
    }
}

Way-2 declare and attach during runtime : loosly coupled pattern


package com.airbus.oo.groovy.isa.traits

trait Advanced {
    String doStuff() {
        'I am Dynamic'
    }
}


//binding trait dynamically
def machine = new Machine() as Advanced;
println machine.doStuff()

def flyingMachine = new Machine() as Flyable;
println flyingMachine.fly()

..........................................................................................
				Attach more traits dynamically
..........................................................................................


def newMachine = new Machine()
//attach features
def newMachineWith = newMachine.withTraits(Advanced, Flyable)
println(newMachineWith.fly() + " " + newMachineWith.doStuff())
.............................................................................................
				static variables and methods
.............................................................................................

How to share data across the application?

 static variables and methods

-static variables are not instance specific, can be shared across multiple instances



instance variables and methods
   variables and mehtod are declared inside class , can be accessed by that object only.

static variables and methods
  variables and mehtod are declared inside class with static keyword , can be accessed by  any object in the application.


static variables:

1.declare static variable inside class with any data type.
2.variables are declared in capital letters.
3.static keyword must be used infront of type
4.public scope must be used 
5.static variables must be initalized
6.No setters and getters.

7.How to access static variables?

  Dont create Object

 Access via
  ClassName.variable

8.static variables should not be re initalized other parts of the program.
  
add one more keyword - final : constant.


package com.airbus.oo.groovy.staticinfo

class Message {
    static String INFO_MESSAGE = "info";
    static final String WARN_MESSAGE = "Warn";
    static final String ERROR_MESSAGE = "Error";
    static final String SUCCESS_MESSAGE = "Success";
}
import com.airbus.oo.groovy.staticinfo.Message

println(Message.ERROR_MESSAGE)
println(Message.WARN_MESSAGE)
println(Message.SUCCESS_MESSAGE)
............................................................................................
				DSL - Domain specific Language

1.Functional Programming - Closure
2.Collections - List,Map
3.Groovy IO -  File Reading,writing,Json /XML Parsing
.............................................................................................
				Collections  -Data Structure
.............................................................................................
There are three data structure:

1.List
   collection of items organized based on index
  
2.Set 
   Collection of items organized based on "values natural order".

List and set both are same
  =>List allows duplicates values
  =>Set never allows duplicates values

3.Map
  Two dimensional datastructure.
  key-value pair datastructure



Array:
  Collection of many times

List :  
 Collection of many items

Array is static and fixed and List is dynamic

int a =10 ; single item

List:

def numbers = [1, 2, 3, 4, 5, 9]
def value = numbers.get(1)
println(value)
//how to read all value : for loop  , provide iterators are api to read values
numbers.forEach(i -> println(i)) // functional programming is used ; java style

numbers.each { i -> println(i) }
//remote {
//            url('https://github.com/jenkinsci/job-dsl-plugin.git')
//          }

.............................................................................................

Map :

 key : value datastructure
.............................................................................................

//Map with items
//map

def product = [
        id   : 1,
        name : 'Phone',
        qty  : 100,
        price: 10000.78
]
//println(product.get(0))
product.each { entry -> println(entry) }

product.each { entry -> println("${entry.key} ${entry.value}") }


//map

def product = [
        id   : 1,
        name : 'Phone',
        qty  : 100,
        price: 10000.78
]
//println(product.get(0))
product.each { entry -> println(entry) }

product.each { entry -> println("${entry.key} ${entry.value}") }


//nested Map
def users = [
        id    : 1,
        name  : 'Subramanian',
        skills: [
                skillId: 100,
                skill  : 'Groovy'
        ]
]
//println("Skill Id" + users.get("skills").get("skillId"))
//println("Skill Value" + users.get("skills").get("skill"))

//users.each { entry ->
//    {
////        if (entry.key instanceof java.util.Map) {
////            print("...")
////        }
//        println(entry.key + (entry.key instanceof java.util.Map) + " " + entry.value)
//
//    }
//}

print(".........")
users.each {key,value->
    println("${key} ${value}")
    if(value instanceof  java.util.Map){
        println(value.get("skillId") + value.get("skill"))
    }
}
..............................................................................................
                                 DSL - Functional Programming
............................................................................................

What is functional programming?

 Functional programming is the application/implementation of "Lambda Calculs".
Functional programming:
.......................

Groovy is dynamic,object oriented , functional style programming languages.


functional programming:

functional programming invented by Alonzo Church

In 1930 two computation models were proposed.


State Machine/Turing Machine:
  Turing machine is  also formal system in mathematical logic for expressing computation based on variable abstraction.

Lambda calculus:
   Lambda calculus (also written as -calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.

      The functional programming is the reference implementation of lambda calculs.

LISP is the first Programming language implemented "functional programming" / "Lambda Calculs".

*********************************************************************************************
Functional programming is application of lambda calculs mathetical theroy.


Functional Programming principles:lambda calculs mathetical

1.side effects
2.Pure functions
3.immutablity : referential transparency.
4.function is the first class cizitens
5.no loops, but recurrsion.
6.Higher order function
//////////////////////////////////////////////////////////////////////////////////////////////
	    Groovy implements - Higher order function/function is first class citizen
		
..............................................................................................

Function is value like others.

int a =10;
Employee emp  = new Employee();

here 
a is variable its value is no
emp is variable its value is Employee Object

you can declare variable, it can hold function as value - Function is first class citizen.

Since function is value, it can be passed to another function as parameter , and can be returned from another function : Higher order function

/////////////////////////////////////////////////////////////////////////////////////////////

              Functional Programming concepts and implementation in Groovy
				(Closures)
.............................................................................................

What is Closure?

 The closure is object, used to implement functional programming in groovy.

 The closure is an open , anonymous(nameless),block of code that can take arg,return a value
and be assigned to a variable, can be passed as a parameter to another clousre or method.

 closure is method /function.

 "closure is free code"

 "Closure is a literal" - value like 10 ,"hello" ,true, 

Since closure is a literal, can be assigned to a variable,that variable can be used to invoke
that closure(method/function)
..............................................................................................

   int a=10;

Basic closure syntax:
.....................

def func = { code }

func() // function invocation

How to declare closure and invoke?

//how to declare closure and initalize them

def func = {
    //function body
    println("Hello , Closure")
    println("Hello , Closure")
    println("Hello , Closure")
    println("Hello , Closure")
    println("Hello , Closure")

}
//invoke closure
func()
............................................................................................
//Groovy closure parameters and args

//-> Arrow : which separates body of the function and args
//Strong typing
def add = null
add = { int a, int b ->
    def result = a + b
    println("The Result is ${result}")
}
add(10, 10)

//if you dont pass values
add = { int a = 0, int b = 0 ->
    def result = a + b
    println("The Result is ${result}")
}
add()

//dynamic parameters
add = { def a = 0, def b = 0 ->
    def result = a + b
    println("The Result is ${result}")
}
add(5, 8)

//dynamic parameters without even def keyword
add = { a = 0, b = 0 ->
    def result = a + b
    println("The Result is ${result}")
}
add(5, 8)
..............................................................................................
					Single Args


def sayHello = null;

sayHello = { name -> println("Hello $name") }
sayHello('Subramanian')

implicit "single parameter called  it"

"it" - it is keyword used to replace explicit single parameter.


//single parameter
def sayHello = null

sayHello = { String name ->
    println("Hello $name")
}
sayHello("Subramanian")

sayHello = { name ->
    println("Hello $name")
}
sayHello("Subramanian")

//add it
sayHello = { it ->
    println("Hello $it")
}
sayHello("Subramanian")
//without any explicit parameter
sayHello = {println("Hello $it") }
sayHello("Subramanian")
............................................................................................
				Returning values from the Closure
.............................................................................................
//How to return values from the groovy.
def add = null;
add = { a = 1, b = 2 ->
    def result = a + b;
    return result;
}
println(add(10, 10))
//no return statement is needed.
add = { a = 1, b = 2 ->
    def result = a + b;
    result;
}
println(add(10, 10))
/////////////////////////////////////////////////////////////////////////////////
// if you have single parameter and you want to return
def getName = { it }
println(getName('Ram'))

............................................................................................
				Closure Object
............................................................................................

//Generics
Closure<Boolean> isOdd = {
    it % 2 != 0 // return true or false
}
isOdd(3) ? println("Odd") : println("Even")
//another way of calling closure
isOdd.call(4) ? println("Odd") : println("Even")
..............................................................................................
				Higher order function
.............................................................................................

functions(closures) can be passed as parameter to another function(closure) or any object method.

//Function as parameter

//method takes String parameter
def sayGreet(String name) {
    println "$name"
}
//hardcode value
sayGreet('Subramanian')
def firstName = 'Subramanian';
sayGreet(firstName);
///////////////////////////////////////////////////////////////////////////////////////////////////
//callback is just Variable going to hold function
def connect(Closure<Void> callback) {
    //call the variable
    callback()
}

//passing closure variable
def webServer = {
    println "WebServer is connecting"
}
connect(webServer)
//passing closure directly
connect({
    println "My another web Server"
})
//DSL code : Ommiting ()
connect {
    println "My another web Server "
}
///

Higher orders and parameters and return


void startWebServer(Closure<Void> callback) {
    callback('Running') //single parameter
}

startWebServer {
    println  "Weberver is $it"
}

............................................................................................
void startWebServer(Closure<Void> callback) {
    callback('Running') //single parameter
}

startWebServer {
    println "Weberver is $it"
}

void job(Closure<Boolean> callback) {
    def status = callback('job')
    status ? println("job is running") : println("Job is not running")
}

job {
    it == 'job' ? true : false
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//multi clsoure parameter
void login(String name = "", String password = "", Closure<Void> resolve, Closure<Void> reject) {
    (name == 'admin') && (password == 'admin') ? resolve('Login Success') : reject('Login failed')
}

//positional parameters
login("admin", "admin", {
    println it
}, {
    println it
})
login "foo", "bar", {
    println it
} {
    println it
}
..............................................................................................
				Closure Accepts another closure as arg
.............................................................................................

println "Closure as parameter to another closure"
def auth = { userName, password, resolve, reject ->
    if (userName.equals('admin') && password.equals('admin')) {
        resolve('Login Success')
    } else {
        reject('Login failed')
    }
};
auth('admin', 'admin', { println "$it" }, { println "$it" });

//more dsl code, strings are enclosed within bracket and used common, but closure not necessary
auth('admin', 'admin') { println "$it" } { println "$it" }
..............................................................................................
				  Nested Closure
..............................................................................................

/**
 * if you want to call inner closure
 * 1.within outer closure
 * 2.outside outer closure
 */
def outerClosure = {
    println "Outer closure"
    def innerClosure = {
        println "Inner Clsoure"
        def innerMostClosure = {
            println "InnerMost Closure"
        }
        innerMostClosure()
    }
    innerClosure()
}
//calling outer class
outerClosure()

//calling from outside
def outerClosure = {
    println "Outer closure"
    def innerClosure = {
        println "Inner Clsoure"
        def innerMostClosure = {
            println "InnerMost Closure"
        }
    }
}
//calling from outside class
outerClosure()()()
.............................................................................................
				Nested Closures and parameters - single args
.............................................................................................

//single params
def outerClosure = {
    println "Outer closure $it"
    def innerClosure = {
        println "Inner Clsoure $it"
        def innerMostClosure = {
            println "InnerMost Closure $it"
        }
    }
}
//calling from outside class
outerClosure("Hello")("How are you")("Welcome")
def multiArgsOuter = { String name, String message ->
    println "Outer closure $name $message"
    def multiArgsInner = { String nameOne = "one", String messageOne = "msg1" ->
        println "Inner Clsoure $nameOne $messageOne"
        def multiArgsInnerMost = { String nameTwo = "n2", String messageTwo = "msg2" ->
            println "InnerMost Closure $nameTwo $messageTwo"
        }
    }
}
multiArgsOuter('Subramanian', 'Hello')()()

..............................................................................................
			return closure from method or another closure.
.............................................................................................

//def counter() {
//    int a = 0;
//    def innerClosure = {
//        ++a; //closure returns value
//    }
//    return innerClosure;
//}
//Without Return Statement:
//def counter() {
//    int a = 0;
//    def innerClosure = {
//        ++a;
//    }
//}
//without assigning closure
def counter() {
    int a = 0;
    //This is invalid , because compiler understands that {} is function or scope syntax
//    {
//        ++a;
//    }
    //if you want to return clsoure without assigning you have to use return statement
    return {
        ++a;
    }
}

def res = counter()
println res()
println res.call()
println counter().call()

//return closure from another closure

def myCounter = {
    int a = 0;
    return {
        ++a + it
    }
}
println(myCounter().call(10))
..............................................................................................
				Closure are every where in groovy
.............................................................................................

Many apis are using closures - collections -  list,map,set....

//List
def list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
//process data in pipelines : Data process is done in stage by stage
list.stream()
        .filter { it % 2 == 0 } //filter even numbers
        .map { it * 2 } //double it all even numbers
        .each { println it }

//i want to find out even numbers from 1 to 1000
def longList = 1..1000 // .. here is range operator

//find out even numbers ,find the first element
longList.stream()
        .filter { it % 2 == 0 }
        .findFirst().orElse(0) // here if element is present return it else return default value 0
        .each { println it }
............................................................................................
				 Closure Delegates
...........................................................................................

Groovy Meta Programming:
   The Groovy language supports two flavors of metaprogramming: runtime and compile-time. The first allows altering the class model and the behavior of a program at runtime while the second only occurs at compile-time.


Runtime Meta Programming:

  The code which is running, generally cant be altered - Java
  Groovy offers a mechanism that while running app /during runtime, we can alter the code
  -Runtime Meta Programming
This feature inspired from "Java Script". 

  During runtime you can alter the object layout.

 - adding new property /binding new Property on existing object
 - Deleting property
 - Updating property.
 - Attach and detach Closures on Object dynamically - Closure Delegates

eg
 def greet = {

 }

I am creating new object called Hello,but greet is not part of Hello while declaring

 class Hello {

 }

Here greet is not part of Hello, but some use cases i want greet inside Hello, i can bind greet closure with Hello dynamically, which is called "Closure delegates"

Delegation:
..........
Dictionary meaning:
 A person designated to act for  or represent another or others; deputy.

Groovy and Delegate:
....................

Groovy language is dynamic language.

As of now , we have discussed "dynamic nature of groovy with respect to type system".

Groovy provides more dynamic programming features.

-During runtime, we can do lot of things on object.
   
A.Dynamic binding of an closure to an Object.

        "This is called delegation"

..............................................................................................
					Keywords in Closure
.............................................................................................

1.this
2.owner
3.delegate


1.this keyword:
   this inside closure , corresponds to the enclosing class where  the closure is defined.

Where we can define closure?

-inside script
-inside groovy class

-inside script

closurethis.groovy
def mycls = {
    println this;
}
mycls()

output: The class Name
closurethis@490caf5f


import org.codehaus.groovy.runtime.InvokerHelper;

class closurethis extends Script {    
                 
    def run() {                                 
  	println "hello";    
        mycls()           
    }
     def mycls = {
   	 println this;
     }

    static void main(String[] args) {           
        InvokerHelper.runScript(HelloWorld, args)     
    }
}

Note: any code if you write will go inside Script Class

 -inside class:
class HelloClosure {
    def hello = {
        println this
    }
}

def myclass = new HelloClosure();
myclass.hello()
.............................................................................................

2.owner :

//owner
def mycls = {
    println "this : " + this;
    println "Owner :"  + owner // who is controlling this closure
}
mycls()
class Foo {
    def myls = {
        println "Foo "
        println "this : " + this;
        println "owner : " + owner;
    }
}
def myclass = new Foo();
myclass.myls()
............................................................................................
			  this vs owner
.............................................................................................

this  => corresponds to the "enclosing class where the closure is defined"
owner => corresponds to the  "enclosing object where the closure is defined" which may be either another class or a closure.
..............................................................................................
			    Delegate 
..............................................................................................

The delegate of a closure can be accessed by the delegate property.
 
Closure  "ownership" can be changed object to object.

delegate property helps to bind closure with any object during runtime.
def mycls = {
    println "this : " + this;
    println "Owner :" + owner // who is controlling this closure
    println "Delegate : " + delegate
}
mycls()

class Bar {
    def myls = {
        println "Bar "
        println "this : " + this;
        println "owner : " + owner;
        println "Delegate : " + delegate

    }
}

def myclass = new Bar();
myclass.myls()
..............................................................................................
				How to change Owner of a closure / How to delegate
.............................................................................................

Closure Part of script:

// if you want to delegate

class Person {
    String name
}

class Visitor {
    String name
}
//define closure
//def sayGreet = {
//    println "this : " + this;
//    println "owner : " + owner;
//    println "Delegate : " + delegate
//}
def sayGreet = {
    //how to access instance variables of object
    delegate.name
}
def person = new Person(name: 'Subramanian')
def visitor = new Visitor(name: 'Ram')
//change Closure Relationship
sayGreet.delegate = person
println sayGreet()
sayGreet.delegate = visitor
println sayGreet()
............................................................................................

Closure inside Object , how to bind one Object of closure on to another object?

class Util {
    def add = {
        delegate.a + delegate.b
    }
}

def util = new Util()

class Math {
    int a;
    int b
}

def math = new Math(a: 10, b: 20)
util.add.delegate = math
println util.add()
..........................................................................................
Delegation Strategy:
....................

lookup mechnism:


eg:

def upperCasedName = {
    println "this : ${this}"
    println "Owner : ${owner}"
    println "Delegate : ${delegate}"
    println("${name.toUpperCase()}")
}
upperCasedName()


this : ClosureDelegeStrategy@69f1a286
Owner : ClosureDelegeStrategy@69f1a286
Delegate : ClosureDelegeStrategy@69f1a286
Caught: groovy.lang.MissingPropertyException: No such property: name for class: ClosureDelegeStrategy
groovy.lang.MissingPropertyException: No such property: name for class: ClosureDelegeStrategy
	at ClosureDelegeStrategy$_run_closure1.doCall(ClosureDelegeStrategy.groovy:6)
	at ClosureDelegeStrategy$_run_closure1.doCall(ClosureDelegeStrategy.groovy)
	at ClosureDelegeStrategy.run(ClosureDelegeStrategy.groovy:8)

///////////////////////////////////////////////////////////////////////////////////////////

How to change the lookup order?

Groovy first sees the method of owner, if not present, it will look up  in the delegate object.

Closure writer = {
    println "Owner $owner"
    println "this $this"
    println "delegate ${delegate}"
    println append(it);
}
//script append method: writer's owner method
def append(String str) {
    "Fake append"
}

StringBuffer sb = new StringBuffer();
//writer.resolveStrategy = Closure.DELEGATE_FIRST
//writer.resolveStrategy = Closure.OWNER_FIRST
writer.delegate = sb;
writer('Hello')
writer('Hello')
writer('Hello')


Default is "Owner First"
//////////////////////////////////////////////////////////////////////////////////////////
Closure.OWNER_FIRST ->lookup owner first, if not lookup delegate, if not ,will throw error
Closure.DELEGATE_FIRST -> lookup delegate first, if not owner , if not will thorw error.
Closure.OWNER_ONLY - lookup only in owner, if not , will throw error
Clousre.DELEGATE_ONLY - lookup only in delegate , if not will throw error.
////////////////////////////////////////////////////////////////////////////////////////////
//Delegation Strategy: how to lookup the properties
//def name = 'foo'
//def upperCasedName = {
//    println "this : ${this}"
//    println "Owner : ${owner}"
//    println "Delegate : ${delegate}"
//    println("${name.toUpperCase()}")
//}
//upperCasedName()

//script append method: writer's owner method
def append(String str) {
    "Fake append"
}

Closure writer = {
    println "Owner $owner"
    println "this $this"
    println "delegate ${delegate}"
    println append(it);
}

def greet(String message) {
    "Greet $message"
}

def sayGreet = {
    greet it
}
writer "Hai"
println " ........"
StringBuffer sb = new StringBuffer();
//by default groovy looksup methods in the owner, if you want to change
writer.resolveStrategy = Closure.DELEGATE_FIRST
writer.delegate = sb
writer "Hello"
//First lookup sayGreet in the StringBuffer
sayGreet.resolveStrategy = Closure.DELEGATE_FIRST
sayGreet.delegate = sb
println sayGreet("Hello")
..............................................................................................
				Compile Time Meta Programming
..............................................................................................

Compile-time meta Programming in groovy allows code generation at compile-time.
Compiler generally generates a program (compiled program)  based on a concept "AST"
Abstract Syntax Tree - tree representation of compiled program.

Source code----compile----ast---executed.

Groovy hooks AST Transformation during compilation process.

When compare to Runtime meta programming, compile time meta programming will have changes in the byte itself -  eager process.

Implementation:
  AST transformation is done via "Annotations"

@groovy.transform - package provides compile time meta programming instructions.
import groovy.transform.ToString

@ToString(includes = ['id', 'name'])
class Employee {
    Integer id
    String name
    Double salary
}

def emp = new Employee(id: 1, name: 'Subramanian', salary: 1000.78)
println emp
//println( emp.id + emp.name + emp.salary)
..............................................................................................
				  File IO
.............................................................................................

How to read File ?

def baseDir = "./"
//new File(baseDir, 'haiku.txt').eachLine { line ->
//    println line
//}
//new File(baseDir, 'haiku.txt').eachLine { line,nb ->
//    println "$nb $line"
//}
//def count = 0, MAXSIZE = 3
//new File(baseDir,"haiku.txt").withReader { reader ->
//    while (reader.readLine()) {
//        if (++count > MAXSIZE) {
//            throw new RuntimeException('Haiku should only have 3 verses')
//        }
//    }
//}
//def list = new File(baseDir, 'haiku.txt').collect {it}
//list.stream().filter(item->item.startsWithIgnoreCase("a")).map(String::toUpperCase).each {println it}

//def file = new File(baseDir,"haiku.txt").eachByte {println it}

//def file = new File(baseDir,"haiku.txt").eachByte {println it as char}

//def file = new File(baseDir,"haiku.txt").eachByte {println it as char}
//def file = new File(baseDir, "haiku.txt")
//byte[] contents = file.bytes
//println "length of the file $contents.length"
//contents.each { println it }

//Using input stream
//def file = new File(baseDir, "haiku.txt").newInputStream()
//byte[] contents = file.bytes
//println "length of the file $contents.length"
//contents.each { println it }

//def file = new File(baseDir, "haiku.txt").withInputStream { stream ->
//    byte [] bytes = stream.bytes
//    bytes.each {println it}
//}
...

How to write data into file?
def baseDir = "./"
new File(baseDir,'haikutemp.txt').withWriter('utf-8') { writer ->
   writer.writeLine 'Into the ancient pond'
   writer.writeLine 'A frog jumps'
   writer.writeLine 'Waters sound!'
}
..............................................................................................
				  Operator Overloading
..............................................................................................

Changing the meaning of operator.

eg:

 +

what is use of + operator?

=> To add two numbers 10 +10
=> To concat strings "Hello" + name

Groovy supports operator overloading where as java does not.

<< -  write operator
.............................................................................................

def baseDir = "./"
//eachLine reads data in the form of string
// new File(baseDir, 'haiku.txt').eachLine {
//     println it
// }

//read file with line no
// new File(baseDir, 'haiku.txt').eachLine { line,nb ->
//    println "$nb $line"
// }

//if you want to read file using java apis
// new File(baseDir,"haiku.txt").withReader { reader ->
//    while (reader.readLine()) {
//        println reader.readLine()
//    }
// }
//if you want to process file content.
//store file content into list
// def list = new File(baseDir, 'myfile.txt').collect {it}
// //you can convert into data stream:so that you can process
// list.stream().filter(item->item.startsWithIgnoreCase("a")).map(String::toUpperCase).each {println it}


// def file = new File(baseDir,"haiku.txt").eachByte {println it}

// def file = new File(baseDir,"haiku.txt").eachByte {println it as char}

// def file = new File(baseDir, "haiku.txt")
// byte[] contents = file.bytes
// println "length of the file $contents.length"
// contents.each { println it }

def file = new File(baseDir, "haiku.txt").newInputStream()
byte[] contents = file.bytes
println "length of the file $contents.length"
contents.each { println it }

def file = new File(baseDir, "haiku.txt").withInputStream { stream ->
   byte [] bytes = stream.bytes
   bytes.each {println it}
}
............................................................................................

def baseDir = "./"
new File(baseDir,'haikutemp.txt').withWriter('utf-8') { writer ->
   writer.writeLine 'Into the ancient pond'
   writer.writeLine 'A frog jumps'
   writer.writeLine 'Waters sound!'
}

// //using write operator
// def title = "Airbus-Home"
// def content="""
//       Into the ancient pond
//       A frog jumps
//       Waters sound!
//     """
// new File(baseDir, 'sample.txt') << """
//      <html>
//        <head>
//      <title>${title}</title>
//      </head>
//      <body>
//          ${content}
//      </body>
//      </html>
// """
// println "File content has been written"

..............................................................................................
			  How to extract word from the file and update the same

def baseDir="./"

//Step: 1 read file For 
def myFile = new File(baseDir,"version.txt") 
//extract text content
def text = myFile.text
//declare pattern to match String NEW_VERSION = 1.0.1
def (foundText) = (text =~ /NEW_VERSION = (\d{1,3})\.(\d{1,3})\.(\d{1,3})/)[0]

//value to be supplied to replace existing version infro
def version = "4.0.1"

//Write Operation
def file =  new File(baseDir , "version.txt")
//replace old string to new string
def newConfig = file.text.replaceAll(foundText, "NEW_VERSION = ${version}")
//update the file with new data
file.text = newConfig
println text













............................................................................................
				JSON Processing
............................................................................................

JsonSlurper:
  JSON TO Groovy Data Structure - JSON(String) to Object 

json you may have in the file or may be in the code.

JsonSlurper object has method called parseText

def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText('{ "name": "John Doe" } /* some comment */')

import groovy.json.JsonSlurper

//map object
def json = new JsonSlurper()
def map = json.parseText('{"name" : "Subramanian"}')
println map

def jsonList = new JsonSlurper()
def list = jsonList.parseText('{ "myList": [4, 8, 15, 16, 23, 42] }')
println list
// parsing data from the json file.
//load json from json file
def jsonFile = new JsonSlurper()
def response = jsonFile.parse(new File("./", "todos.json"))
println response

..............................................................................................
				 JsonOutput  - Convert object to String(json)
..............................................................................................
import groovy.json.JsonOutput

def data = [
        name     : "Foo Bar",
        year     : "2018",
        timestamp: "2018-03-08T00:00:00",
        tags     : ["person", "employee"],
        grade    : 3.14
]
def baseDir = "./"
def json_str = JsonOutput.toJson(data)
def json_beauty = JsonOutput.prettyPrint(json_str)
new File(baseDir, 'emp.json') << json_str
print json_beauty
..............................................................................................
			How to run linux commands
.............................................................................................

Process:

Groovy offers java.lang.Process Object to run os specific commands like linux,windows shell commands.

def process = "ls -l".execute()
// println "Found text ${process.text}"
//println process
process.in.eachLine { line ->               
    println line                            
}
............................................................................................
				REST API Communication
.............................................................................................

1.groovy URL object -Very old 

2.Third party Groovy HttpBuilder - you have to install

3.Java HTTP Builder - recommeneded object


Java 11 HTTP Object which eq to Groovy URL object.

Steps:

1.Create HTTP Client Object

HttpClient httpClient = httpClient = HttpClient
                .newBuilder()
                .version(HTTP_1_1)
                .followRedirects(NORMAL)
                .connectTimeout(ofSeconds(20))
                .build();


2.Create HTTP Request Object

    def url = "https://jsonplaceholder.typicode.com/todos";
    def request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .build();

3.Make HTTP call.
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse

import static java.net.http.HttpClient.Redirect.NORMAL
import static java.net.http.HttpClient.Version.HTTP_1_1
import static java.time.Duration.ofSeconds

class TodoService {
    HttpClient httpClient;

    public TodoService() {
        httpClient = HttpClient
                .newBuilder()
                .version(HTTP_1_1)
                .followRedirects(NORMAL)
                .connectTimeout(ofSeconds(20))
                .build();
    }

    public void getAllTodos() {
        def url = "https://jsonplaceholder.typicode.com/todos";
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .build();
        try {
            def response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            //print all response details
            def body = response.body();
            System.out.println(body);


        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

def todoService = new TodoService();
todoService.getAllTodos();
















..............................................................................................


def text ="""
import os, sys
import shutil
import glob
import subprocess
from change_version import change_version

NEWVERSION = 1.0.1

LIST = "ALL"

"""
// def (_,price,discount) = (text =~ /NEWVERSION = (\d{1,3})\.(\d{1,3})\.(\d{1,3})/)[0]

def version = "1.4.5"
// print _ 
def (_,price,discount) = (text =~ /NEWVERSION = (\d{1,3})\.(\d{1,3})\.(\d{1,3})/)[0]

result = text.replaceAll(_, "NEWVERSION = ${version}")

print result































































